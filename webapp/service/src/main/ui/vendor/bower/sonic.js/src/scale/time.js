/**
 * A time scale component
 */
sonic.scale.time = function (viz, initialConfig) {
    var p = {
        d3Scale: null, //underlying d3 scale
        config: {
            /** 
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is 
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * The field that each data point uses for its scale value
             */
            dataKey: null,
            /**
             * The position of the scale (left, right, top, bottom) used 
             * to determine how to draw the range
             */
            pos: null,
            /**
             * The piece of the range to use to draw the scale within.  By 
             * default, will assume the full viz body height/width (depending 
             * on position), but this can be overridden.  For example, [0, .25]
             * would take up a quarter of viz body, along whichever 
             * edge the axis lies, [.25, .75] would take up middle 50%, etc.
             */
            range: null
        }
    };

    /**
     * Scale constructor generates and returns a d3 scale
     */
    function scale() {
        if (sonic.timezone === 'UTC') {
            p.d3Scale = d3.time.scale.utc()
                .domain(p.computeDomain())
                .range(p.computeRange());
        } else {
            p.d3Scale = d3.time.scale()
                .domain(p.computeDomain())
                .range(p.computeRange());
        }
    }

    /** Update this scale instance */
    scale.update = sonic.override(function () {
        return scale();
    });

    /** Getter for underlying scale */
    scale.scale = function () {
        return p.d3Scale;
    };

    /**
     * Getter/setter for domain (e.g. [minVal, maxVal])
     *
     * setToMax, if this fn used as a setter, will broaden the
     * existing domain based on both old and new domain, rather
     * than just using the new one wholesale
     *
     * TODO: Make sure this and scale.resetDomain actually work
     */
    scale.domain = function (domain, setToMax) {
        if (!sonic.isSet(domain)) {
            return p.d3Scale.domain();
        }

        if (setToMax) {
            p.d3Scale.domain(d3.extent(p.d3Scale.domain().concat(domain)));
        } else {
            p.d3Scale.domain(domain);
        }
    };

    scale.resetDomain = function () {
        scale.domain(p.computeDomain());
    };

    /** 
     * Takes in an interval value and finds the corresponding domain value 
     * for the first time in domain + interval
    */
    scale.domainIntervalToRange = function (val) {
        return p.d3Scale(new Date(p.d3Scale.domain()[0].getTime() + val));
    };

    /**
     * Takes in a range pixel value and finds the value difference between that 
     * and the first time in domain
     *
     * Useful to find a physical buffer space based on pixels
     */
    scale.domainRangeToInterval = function (val) {
        return p.d3Scale.invert(val).getTime() - p.d3Scale.domain()[0].getTime();
    };

    /**
     * When updating scale in axis, will direct code
     * to scale.range. This function differs in each scale type
     */
    scale.resetScale = function (range) {
        return this.range(range);
    };

    /**
     * Getter/setter for the range itself
     */
    scale.range = function (range) {
        if (!sonic.isSet(range)) {
            return p.d3Scale.range();
        }

        p.config.range = range;
        p.d3Scale.range(p.computeRange());

        return scale;
    };

    /**
     * Getter for the range extent
     */
    scale.rangeExtent = function () {
        return sonic_scale_range_extent(scale);
    };

    /**
     * Getter for the range min
     */
    scale.rangeMin = function () {
        return d3.min(p.d3Scale.range());
    };

    /**
     * Getter for the range max
     */
    scale.rangeMax = function () {
        return d3.max(p.d3Scale.range());
    };

    /**
     * Find the nearest value to the point based in, based on the 
     * data also passed in.  
     *
     * This happens here because the scale knows the data key, and also 
     * how to traverse the domain
     */
    scale.nearest = function (pnt, dat) {
        var nearest,
            val = pnt[p.config.dataKey];

        sonic.each(dat, function (k, v) {
            var currDist;

            currDist = Math.abs(v[p.config.dataKey].getTime() - val);

            if (!sonic.isSet(nearest)) {
                nearest = {};
            }

            if (!sonic.isSet(nearest.dist) || currDist < nearest.dist) {
                nearest.point = v;
                nearest.dist = currDist;

                if (currDist === 0) {
                    return false;
                }
            }
        });

        return nearest;
    };

    /**
     * Sort the values passed in, based on the data key
     */
    scale.sort = function (vals) {
        return vals.sort(sonic.sortByProp(p.config.dataKey));
    };

    /**
     * Get the distance in milliseconds between 2 values
     */
    scale.domainDistance = function (a, b) {
        return a.getTime() - b.getTime();
    };


    /**
     * Get the number of days in the domain
     */
    scale.numDays = function () {
        return d3.time.days(p.d3Scale.domain()[0], p.d3Scale.domain()[1]);
    };

    /** Getter for the position along the scale for the passed in value */
    scale.position = function (val) {
        return p.d3Scale(val);
    };

    /**
     * Exposes the d3 method for inverting a pixel range value into a 
     * domain value
     */
    scale.invert = function (val) {
        return p.d3Scale.invert(val);
    };

    /** Getter for the data key */
    scale.dataKey = function () {
        return p.config.dataKey;
    };

    /** Getter for the scale type */
    scale.type = function () {
        return 'time';
    };

    /**
     * Compute the data domain for this scale.  Use the base scale domain generator, then 
     * do linear scale related checks/adjustments
     *
     * @todo some of these checks, like same domain min/max and config need to be rethought
     */
    p.computeDomain = function () {
        var offset,
            domain,
            hours;

        domain = sonic_scale_compute_base_domain(viz.data(), p.config);

        if (domain.length === 0) {
            return [new Date(0), new Date(1000000)];
        }

        domain[0] = new Date(domain[0]);
        domain[1] = new Date(domain[1]);

        if (domain[0] === domain[1]) {
            //1 hour
            offset = 60 * 60 * 1000;
            hours = domain[0].getTime() % offset;
            if (hours === 0) {
                domain[1] = new Date(domain[1].getTime() + offset);
            } else if (hours === 23) {
                domain[0] = new Date(domain[1].getTime() - offset);
            } else {
                domain[0] = new Date(domain[0].getTime() - offset);
                domain[1] = new Date(domain[1].getTime() + offset);
            }
        }

        if (p.config.pad) {
            if (p.config.pad.max) {
                domain[1] = new Date(domain[1].getTime() + p.config.pad.max);
            }
            if (p.config.pad.min) {
                domain[0] = new Date(domain[0].getTime() - p.config.pad.min);
            }
        }

        return domain;
    };

    /**
     * Use the base scale fn to generate the pixel range to show scale within
     */
    p.computeRange = function () {
        return sonic_scale_compute_range(
            viz,
            p.config.pos
        );
    };

    sonic.augment(scale, p, viz, 'registerable');
    //merge config
    scale.mergeConfig(initialConfig);

    scale();

    viz.register('scale', scale);

    return scale;
};
