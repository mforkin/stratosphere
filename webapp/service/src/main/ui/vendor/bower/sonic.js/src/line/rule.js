/**
 * Adds rules (vertical or horizontal lines) to the viz
 *
 * @param {sonic.viz} the viz the bars are being added to
 * @param {object} c the rules config (see below for options)
 */
sonic.line.rule = function (viz, initialConfig) {
    var p = {
        config: {
            /**
             *  Unique id for this rule
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * Set of css classes to add to the rule
             */
            cls: '',
            /**
             * If user wants to pin rule to a value, must provide the axis id
             * x or y value.
             *
             * Must be of the same axis type. For ex: type "time" means that the
             * value of x or y needs to be a date object.
             */
            axisPin: {
                id: null,
                x: null,
                y: null
            },
            /**
             * Controls the line. If dashed, show = true. Stroke
             * config allows user to determine spacing of the line. "3, 3" translates
             * to 3 pixels on and 3 pixels off.
             */
            dashed: {
                show: false,
                stroke: '3,3'
            },
            stroke: 'grey',
            strokeWidth: 1,
            position: null,
            type: null,
            length: null,
            //@todo: create offset for x and y direction.
            offset: {
                length: 0
            },
            followMouse: false
        }
    };

    /**
     * Bar constructor renders the rules
     *
     * @param {d3.selection} sel where to render the bars to
     * @param {Object} opts extra information on how to render the bars
     *   generally used to specify custom transitions
     */
    function rule(sel, opts) {
        var classes = [p.config.cls, 'sonic-rule'],
            groups,
            paths,
            scale;

        //update this bar instance's selection to match the current one
        p.selection = sel;
        opts = opts || {};

        if (sonic.isSet(p.config.axisPin.id)) {
            scale = viz.componentSingleton().find('sonic-axis', p.config.axisPin.id)[0].scale();
        }

        p.computeData(opts, scale);

        groups = sel.selectAll('.sonic-rule.' + rule.id())
            .data(p.data, function() {
                return rule.id();
            });

        groups.enter().append('g')
            .classed('sonic-rule ' + rule.id() + ' ' + p.config.type, true)
            .classed('mouse', function (d) {
                return p.config.followMouse;
            })
            .attr('stroke', p.config.stroke)
            .append('path')
                .attr('stroke-width', p.config.strokeWidth)
                .attr('opacity', function (d, i) {
                return d[0].enabled ? 1 : 0;
            });

        groups.each(p.drawRule);

        groups.exit().remove();

        //we never want to tell the viz we have rendered content
        //because we shouldn't impact the no data message
        viz.registerVisibleContent(rule, false);
    }

    p.drawRule = function (series, i) {
        var line = d3.svg.line()
            .x(function (d) { return d.x; })
            .y(function (d) { return d.y; }),
            rule,
            delay = viz.animation().delay,
            duration = viz.animation().duration;

        if (p.config.followMouse) {
            delay = 0;
            duration = 0;
        } else if (p.config.animation) {
            delay = sonic.isSet(p.config.animation.delay) ? p.config.animation.delay : delay;
            duration = sonic.isSet(p.config.animation.duration) ? p.config.animation.duration : duration;
        }

        rule = d3.select(this).select('path')
                .transition()
                .delay(delay)
                .duration(duration)
                .attr('d', line);

        if (p.config.dashed.show) {
            rule = rule.style('stroke-dasharray', p.config.dashed.stroke);
        }
    };

    p.computeData = function (opts, scale) {
        var pos = p.config.position,
            enabled = true,
            length,
            offset,
            yVal = pos * viz.body().height(),
            xVal = pos * viz.body().width();

        p.data = [];

        if (opts.remove) {
            return;
        }

        //if no position passed in, assume that this is
        //disabled and going to be set later (either by
        //following mouse or something else)
        if (!sonic.isSet(pos) && !sonic.isSet(p.config.axisPin.x) && !sonic.isSet(p.config.axisPin.y)) {
            enabled = false;
            pos = 0;
        }

        if (p.config.type === 'x') {
            if (p.config.length) {
                length = p.config.length;
            } else {
                length = viz.body().width();
                if (p.config.offset.anchor === 'right') {
                    length = -1 * length;
                }
            }

            offset = p.config.offset.length;
            if (p.config.offset.anchor === 'right') {
                offset = offset + viz.body().width();
            }

            if (sonic.isSet(p.config.axisPin.y)) {
                yVal = scale.position(p.config.axisPin.y);
            }

            p.data.push([
                {
                    x: offset,
                    y: yVal,
                    enabled: enabled
                },
                {
                    x: length + offset,
                    y: yVal,
                    enabled: enabled
                }
            ]);
        } else if (p.config.type === 'y') {
            if (p.config.length) {
                length = p.config.length;
            } else {
                length = -1 * viz.body().height();
                if (p.config.offset.anchor === 'top') {
                    length = length * -1;
                }
            }

            offset = viz.body().height() + p.config.offset.length;
            if (p.config.offset.anchor === 'top') {
                offset = p.config.offset.length;
            }

            if (sonic.isSet(p.config.axisPin.x)) {
                xVal = scale.position(p.config.axisPin.x);
            }

            p.data.push([
                {
                    x: xVal + ((p.config.offset && p.config.offset.x) ? p.config.offset.x : 0),
                    y: offset,
                    enabled: enabled
                },
                {
                    x: xVal + ((p.config.offset && p.config.offset.x) ? p.config.offset.x : 0),
                    y: length + offset,
                    enabled: enabled
                }
            ]);
        }
    };

    p.onVizMouseMove = function (mouse) {
        if (mouse) {
            d3.select('.sonic-rule.' + rule.id() + '.mouse.x' + ' path')
                .attr('opacity', 1)
                .attr('transform', function (d) {
                    return 'translate(0 , ' + mouse[1] + ')';
                });
            d3.select('.sonic-rule.' + rule.id() + '.mouse.y' + ' path')
                .attr('opacity', 1)
                .attr('transform', function (d) {
                    return 'translate(' + mouse[0] + ', 0)';
                });
        } else {
            d3.select('.sonic-rule.' + rule.id() + '.mouse' + ' path')
                .attr('opacity', 0);
        }
    };

    sonic.augment(rule, p, viz, 'registerable', 'listenable');
    rule.mergeConfig(initialConfig);
    viz.register('sonic-rule', rule);

    return rule;
};

//add new rule instance
function sonic_line_rule_add (v, c) {
    v.body().call(sonic.line.rule(v, c));
}

function sonic_line_rule_remove (v, p) {
    v.remove('sonic-rule', p);
}

//add crosshairs for mouseover
//In future maybe we pass in extra config so we can
//handle distinct passed config for x and y
function sonic_line_rule_add_crosshair (v, c) {
    sonic_line_rule_add(v, sonic.object.merge(
        {
            type: 'x',
            followMouse: true,
            stroke: '#4CC417'
        },
        c
    ));

    sonic_line_rule_add(v, sonic.object.merge(
        {
            type: 'y',
            followMouse: true,
            stroke: '#4CC417'
        },
        c
    ));
}

function sonic_line_rule_update (v, p, c) {
    v.find('sonic-rule', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

sonic_api.add('addRule', sonic_line_rule_add);
sonic_api.add('removeRule', sonic_line_rule_remove);
sonic_api.add('updateRule', sonic_line_rule_update);
sonic_api.add('addCrosshair', sonic_line_rule_add_crosshair);
