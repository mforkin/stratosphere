/**
 * An ordinal scale component
 */
sonic.scale.ordinal = function (viz, initialConfig) {
    var p = {
        d3Scale: null, //underlying d3 scale
        config: {
            /** 
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is 
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * The field that each data point uses for its scale value
             */
            dataKey: null,
            /**
             * The position of the scale (left, right, top, bottom) used 
             * to determine how to draw the range
             */
            pos: null,
            /**
             * The piece of the range to use to draw the scale within.  By 
             * default, will assume the full viz body height/width (depending 
             * on position), but this can be overridden.  For example, [0, .25]
             * would take up a quarter of viz body, along whichever 
             * edge the axis lies, [.25, .75] would take up middle 50%, etc.
             */
            range: null,
            ticks: {
                /**
                 * fn to sort the domain values
                 */
                sort: function (a, b) {
                    if (a < b) {
                        return -1;
                    } else if (a > b) {
                        return 1;
                    }
                    return 0;
                }
            }
        }
    };


    /**
     * Scale constructor generates and returns a d3 scale
     */
    function scale(sel) {
        p.d3Scale = d3.scale.ordinal()
            .domain(p.computeDomain())
            .rangeBands(p.computeRange());
    }

    /** Update this scale instance */
    scale.update = sonic.override(function () {
        scale();
    });

    /**
     * Getter for underlying scale
     */
    scale.scale = function () {
        return p.d3Scale;
    };

    /**
     * When updating scale in axis, will direct code
     * to scale.rangeBands. This function differs in each scale type
     */
    scale.resetScale = function (range) {
        return this.rangeBands(range);
    };

    /**
     * Getter/Setter for the range
     */
    scale.rangeBands = function (range) {
        if (!sonic.isSet(range)) {
            return p.d3Scale.range();
        }

        p.config.range = range;
        p.d3Scale.rangeBands(p.computeRange());

        return scale;
    };

    /**
     * Getter for the range extent
     */
    scale.rangeExtent = function () {
        return sonic_scale_range_extent(scale);
    };

    /**
     * Getter for the range min
     */
    scale.rangeMin = function () {
        return d3.min(p.d3Scale.range());
    };

    /**
     * Getter for the range max
     */
    scale.rangeMax = function () {
        return d3.max(p.d3Scale.range()) + scale.rangeBand();
    };

    /**
     * Getter for the range band size
     */
    scale.rangeBand = function () {
        return p.d3Scale.rangeBand();
    };

    /**
     * Getter for the position along the scale for 
     * the passed in value
     *
     * If align is not passed, returns the d3 value (which 
     * is beginning of rangeband).  If center, returns the middle 
     * and if max, returns the end
     */
    scale.position = function (val, align) {
        var pos = p.d3Scale(val);

        if (align === 'center' || align === 'bin') {
            pos = pos + p.d3Scale.rangeBand() / 2;
        } else if (align === 'max') {
            pos = pos + p.d3Scale.rangeBand();
        }

        return pos;
    };

    /** Getter for the data key */
    scale.dataKey = function () {
        return p.config.dataKey;
    };

    /** Getter for the scale type */
    scale.type = function () {
        return 'ordinal';
    };


    /**
     * Compute the data domain for this scale by looping through values and finding 
     * unique values
     *
     * @todo some of these checks, like same domain min/max and config need to be rethought
     */
    p.computeDomain = function () {
        var domain = [], temp;

        if (sonic.isArray(p.config.ticks.values)) {
            domain = p.config.ticks.values;
        } else {
            viz.data().forEach(function (s) {
                s.values.forEach(function (d, i) {
                    var dp = d[p.config.dataKey];
                    if (domain.indexOf(dp) === -1) {
                        domain.push(dp);
                    }
                });
            });
        }

        //Need to consider a better solution for multi series charts, the case
        //of grouped verse stacked, and the case where multiple datasets are in viz.data
        if (p.config.ticks.sortType === 'BYVALUE') {
            if (viz.data().length > 0) {
                temp = sonic.clone(viz.data())
                    .sort(p.config.ticks.sort)
                    .map(function (d) {
                        if (d.values.length > 0) {
                            return d.values[0][p.config.dataKey];
                        } else {
                            return "";
                        }
                    });
                domain.forEach(function (d) {
                    if (temp.indexOf(d) === -1) {
                        temp.push(d);
                    }
                });
                domain = temp.filter(function (d) { return d !== ""; });
            }
        } else if (p.config.ticks.sort) {
            domain = domain.sort(p.config.ticks.sort);
        }

        return domain;
    };

    /**
     * Use the base scale fn to generate the pixel range to show scale within
     */
    p.computeRange = function () {
        return sonic_scale_compute_range(
            viz,
            p.config.pos
        );
    };

    sonic.augment(scale, p, viz, 'registerable');
    //merge config
    scale.mergeConfig(initialConfig);

    scale();

    viz.register('scale', scale);

    return scale;
};
