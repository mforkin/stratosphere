/**
 * Adds significance bars (bars over a range where
 * values rose above and/or below a certain significance level
 */
sonic.bar.significance = function (viz, initialConfig) {
    var p = {
        xScale: null,
        yScale: null,
        config: {
            /**
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * The field that each data point uses for its x-axis value
             */
            xDataKey: 'x',
            /**
             * The field that each data point uses for its y-axis value
             */
            yDataKey: 'y',
            /**
             * The field that each data point uses to determine whether or
             * not the point meets a threshold.
             */
            zDataKey: 'z',
            /**
             * Which scale (by id) to use for the x-axis.  Can be passed in, otherwise
             * auto-generated based on xDataKey
             */
            xScaleId: null,
            /**
             * Which scale (by id) to use for the y-axis.  Can be passed in, otherwise
             * auto-generated based on yDataKey
             */
            yScaleId: null,
            /**
             * Defines default low threshold to be any data below .25. This data
             * will appear in a blue bar.
             */
            low: {
                color: 'blue',
                threshold: 0.25
            },
            /**
             * Defines default high threshold to be data higher than .75. This data will
             * appear in a red bar.
             */
            high: {
                color: 'red',
                threshold: 0.75
            },
            /**
             * Defines the area outside of the threshold. Normally no bars are shown, but
             * if hidden: false, than bars will appear at mouse over and tooltip will be
             * activated for that space.
             */
            nonSignificanceBars: {
                hidden: true,
                color: 'transparent'
            },
            /**
             * When active, the color of bars will be brightened depending on how far
             * their value is from the relevant threshold. If you choose to use this,
             * be sure to use darker base colors for the high and low colors. A hover
             * color should be specified since brightness will no longer be a good way
             * to distinguish which bar is being hovered over.
             */
            brightShading: {
                active: false,
                hoverColor: null
            },
            /** Fill opacity */
            fillOpacity: 0.75,
            /** Stroke (border) width */
            strokeWidth: 1,
            /**
             * Padding between bars in bar groups
             */
            barPadding: 3,
            /**
             * Padding between data and the scale ranges. 
             */
            widthPadVal: 0,
            /* Use a pointer cursor when hovering over bars */
            pointerHand: false,
            /** Tooltip config */
            tooltip: {
                type: 'grouped', //todo implement single (1 per line)
                /**
                 * Custom function to render the tooltips
                 *
                 * @param {Object...} Array of closest point objects which
                 * has the closest point, the distance to the mouse, and the
                 * series information
                 * @param {Number...} Mouse position in form [x, y]
                 * @return {String} html
                 */
                renderFn: null
            },
            /**
             * When true, it doesn't allow groups of data to span over
             * x-axis units. 
             */
            suppressGrouping: false
        }
    };

    /**
     * Significance constructor renders the significance bars
     *
     * @param {d3.selection} sel where to render the bars to
     */
    function significance(sel) {
        var groups;

        //update this significance bar instance's selection to match current one
        p.selection = sel;

        p.computeData();
        p.setScales();

        //groups are by series key
        groups = sel.selectAll('.sonic-significance-bar.' + significance.id())
            .data(p.data, function (d) {
                return d.key;
            });

        //create groups for any new series
        groups.enter().append('g')
            .classed('sonic-significance-bar ' + significance.id(), true);

        groups.each(p.drawBars);

        groups.exit().remove();

        viz.registerVisibleContent(significance, significance.hasContent());
    }

    p.onVizClick = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        return cps;
    };

    /**
     * On viz mouse move, find closest points
     * and update tooltips accordingly. Makes the bar under
     * mouse a brighter color.
     */
    p.onVizMouseMove = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        p.updateTooltips(mouse, cps);

        p.selection.selectAll('g.sonic-significance-bar rect')
            .attr('fill', function (d, i) {
                var color;
                if(p.config.brightShading.active){
                    color = p.brightShade(p.config[d.type].color, d.type, d.z);
                } else {
                    color = p.config[d.type].color;
                }
                return (cps &&
                        cps.point[p.config.yDataKey] === d[p.config.yDataKey] &&
                        cps.point[p.config.xDataKey] === d[p.config.xDataKey]) ?
                        (p.config.brightShading.hoverColor || d3.rgb(p.config[d.type].color).brighter().brighter().toString()): color;
            });


        return cps;
    };

    /**
     * Find closest points to mouse, based on rectangle width/height
     */
    p.closestPoints = function (mouse) {
        var x = mouse[0],
            y = mouse[1],
            point = null;

        p.data.forEach(function (d, i) {
            d.values.forEach(function (v) {
                var minX = Math.abs(p.xScale.position(v[p.config.xDataKey])),
                    maxX = Math.abs(p.xScale.position(v[p.config.xDataKey]) + p.getRectWidth(v)),
                    minY = Math.abs(p.yScale.position(v[p.config.yDataKey])),
                    maxY = Math.abs(p.yScale.position(v[p.config.yDataKey]) + p.getRectHeight(v));

                if (minX <= x && maxX >= x && minY <= y && maxY >= y) {
                    point = {
                        point: v,
                        key: d.key
                    };
                }
            });
        });

        return point;
    };

    /**
     * Draw the bars for each series
     *
     * @param {Object} series object
     * @param {Number} i index of series object
     */
    p.drawBars = function (d, i) {

        //set up rects from data
        var rects = d3.select(this).selectAll('rect')
            .data(function (d) {
                return d.values;
            });

        //add new bars with designated strokeWidth and
        // attaches series name to rect
        rects.enter().append('rect')
            .attr('stroke-width', p.config.strokeWidth)
            .attr('fill-opacity', p.config.fillOpacity)
            .attr('series', function (d) {
                return d[p.config.yDataKey];
            })
            .attr('cursor', (p.config.pointerHand ? 'pointer' : ''));

        //load rects with their borders (unless its of type nonSignificanceBars)
        //at the appropriate x,y position and rectangle width/height.
        rects.transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('stroke-width', p.config.strokeWidth)
            .attr('stroke', function (d, i) {
                if (d.type === "nonSignificanceBars") {
                    return;
                } else {
                    return d3.rgb(p.config[d.type].color).darker().toString();
                }
            })
            .attr('fill', function (d, i) {
                if(p.config.brightShading.active){
                    return p.brightShade(p.config[d.type].color, d.type, d.z);
                } else {
                    return p.config[d.type].color;
                }
            })
            .attr('x', function (d, i) {
                return p.xScale.position(d[p.config.xDataKey]);
            })
            .attr('y', function (d) {
                return p.yScale.position(d[p.config.yDataKey]) + p.config.barPadding;
            })
            .attr('width', function (d) {
                return p.getRectWidth(d);
            })
            .attr('height', function (d) {
                return p.getRectHeight(d);
            });

        rects.exit().remove();
    };

    /**
     * Computes rectangle width of the data object.
     * @param {Object} holds x, y, and ztotal of data object
     */
    p.getRectWidth = function (d) {
        var width;

        if (!sonic.isSet(d.toKey)) {
            width = p.xScale.domainIntervalToRange(p.config.widthPadVal);
        } else {
            width = p.xScale.position(d.toKey) - p.xScale.position(d[p.config.xDataKey]);
        }

        return width;
    };

    /**
     * Computes rectangle height of the data object
     * @param {Object} holds x, y, and ztotal of data object
     */
    p.getRectHeight = function (d) {
        return p.yScale.rangeBand() - p.config.barPadding * 2;
    };

    /**
     * Reads in information about a point and transforms it into either a
     * high, low, or, if config = false, a nonSignificance bar.
     *
     * @param {Object} with key = series, and arr of values
     * @param {Object} array that holds like type vlaues
     * @param {String} string value of array type
     * @return {Object} holds all important transform data in a point
     */
    p.transformPoint = function (series, arrType, pointType) {
        var pnt = {};
        pnt[p.config.xDataKey] = arrType[0][p.config.xDataKey];
        pnt.toKey = arrType.length > 1 ? arrType[arrType.length - 1][p.config.xDataKey] : null;
        pnt[p.config.yDataKey] = series.key;
        pnt.type = pointType;
        pnt.ztotal = arrType.length > 1 ? arrType.reduce(function (prev, curr) {
            return {z: prev.z + curr.z};
        }).z : arrType[0].z;
        pnt.z = pnt.ztotal / arrType.length;
        pnt.breakdown = arrType;

        return pnt;
    };

    /**
     * Compute the data based off viz.data() array.
     */
    p.computeData = function () {
        p.data = [];
        viz.data().forEach(function (s) {
            var lowPoints = [],
                highPoints = [],
                hiddenPoints = [],
                vals,
                transformedSeries = {
                    key: s.key,
                    values:[]
                };

            //sort values by xDataKey
            vals = s.values.sort(sonic.sortByProp(p.config.xDataKey));
            vals.forEach(function (d, i) {
                var pnt = {};

                //checks for nonSignificanceBars config. If false and not within threshold, push hiddenPoints into
                // transformedSeries with "nonSignificanceBars" as the type.
                if (p.config.nonSignificanceBars.hidden === false) {
                    if (d[p.config.zDataKey] === 'insignificant' ||
                        ((d[p.config.zDataKey] >= p.config.low.threshold) && (d[p.config.zDataKey] <= p.config.high.threshold))) {
                        hiddenPoints.push(d);
                        pnt = p.transformPoint(s, hiddenPoints, "nonSignificanceBars");
                        transformedSeries.values.push(pnt);
                        hiddenPoints = [];
                    }
                }

                //if less than or = to the low threshold, add it to the lowPoints[]
                if (d[p.config.zDataKey] < p.config.low.threshold) {
                    lowPoints.push(d);
                }

                //transform lowPoints and push to transformedSeries
                if (lowPoints.length && (p.config.suppressGrouping || d[p.config.zDataKey] > p.config.low.threshold || i === vals.length - 2)) {
                    pnt = p.transformPoint(s, lowPoints, "low");
                    transformedSeries.values.push(pnt);
                    lowPoints = [];
                }

                //if >= the high threshold, add it to the highPoints[]
                if (d[p.config.zDataKey] > p.config.high.threshold) {
                    highPoints.push(d);
                }

                //transform highPoints and pus to transformedSeries
                if (highPoints.length && (p.config.suppressGrouping || d[p.config.zDataKey] < p.config.high.threshold || i === vals.length - 2)) {
                    pnt = p.transformPoint(s, highPoints, "high");
                    transformedSeries.values.push(pnt);
                    highPoints = [];
                }
            });

            //add transformed points that have been grouped by threshold to the data set.
            p.data.push(transformedSeries);
        });
    };

    /**
     * Sets the x and y scales for this instance  If an actual scale
     * passed in, uses that.  If a scale id passed in, use it,
     * otherwise find the appropiate scale from the datakey.
     */
    p.setScales = function () {
        if (p.config.xScaleId) {
            p.xScale = viz.findOne('scale', p.config.xScaleId);
        } else {
            p.xScale = viz.findOne('scale', { dataKey: 'x' });
            p.config.xScaleId = p.xScale.id();
        }


        if (!initialConfig.widthPadVal) {
            if (p.xScale.type() === 'time') {
                p.config.widthPadVal = 1000*60*60*24; //one day
            } else if (p.xScale.type() === 'linear') {
                p.config.widthPadVal = 1;
            }
        }

        if (p.config.yScaleId) {
            p.yScale = viz.findOne('scale', p.config.yScaleId);
        } else {
            p.yScale = viz.findOne('scale', { dataKey: 'y' });
            p.config.yScaleId = p.yScale.id();
        }
    };

    /**
     * Updates tooltips
     */
    p.updateTooltips = function (mouse, cps) {
        var renderFn = p.config.tooltip.renderFn || p.renderTooltips;

        if (p.config.tooltip) {
            if (mouse && cps) {
                p.config.tooltip.closestPoints = cps;
                p.config.tooltip.content = renderFn(cps, mouse);
                p.config.tooltip.associatedId = significance.id();
                p.config.tooltip.mouse = mouse;

                viz.showTooltip(p.config.tooltip);
            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    /**
     * Default render tooltip function
     */
    p.renderTooltips = function (cps, mouse) {
        return '<p><b>' + p.config.xDataKey + ': </b>' + cps.point[p.config.xDataKey] + '<br />' +
                '<b>' + p.config.yDataKey + ': </b>' + cps.point[p.config.yDataKey] + '<br />' +
                '<b>' + p.config.zDataKey + ': </b>' + cps.point[p.config.zDataKey] + '</p>';
    };

    /**
     * Makes a bar's color brighter depending on its difference from it's threshold
     *
     * @param {Hex Color} color - base color you are brightening
     * @param {String} type - indicates if bar is in 'high', 'low', or 'non-significance' group
     * @param {Number} - bar's z value to compare to threshold
     *
     * TODO: Come up with formula to adjust adjuster in case value/threshold are ever in the
     * TODO: hundreds, millions, etc. since we want a brighter() k-value between about 0-3.
     * TODO: At 3, color is usually as bright as it can get.
     */
    p.brightShade = function (color, type, value) {
        var adjuster = 100;
        if (type === 'high') {
            return d3.rgb(p.config[type].color).brighter(Math.abs(value - p.config.high.threshold) * adjuster).toString();
        } else if (type === 'low') {
            return d3.rgb(p.config[type].color).brighter(Math.abs(value - p.config.low.threshold) * adjuster).toString();
        } else {
            return p.config[type].color;
        }
    };

    sonic.augment(significance, p, viz, 'registerable', 'listenable');

    significance.mergeConfig(initialConfig);

    viz.register('sonic-significance-bar', significance);

    return significance;
};

//add new significance bar instance
function sonic_bar_significance_add (v, c) {
    v.body().call(sonic.bar.significance(v, c));
}

function sonic_bar_significance_update (v, p, c) {
    v.find('sonic-significance-bar', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

sonic_api.add('addSignificanceBars', sonic_bar_significance_add);
sonic_api.add('updateSignificanceBars', sonic_bar_significance_update);
