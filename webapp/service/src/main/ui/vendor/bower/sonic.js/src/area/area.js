/**
 * Adds an area to the viz.  Areas can be added independent of one another,
 * of stacked
 *
 * @param {sonic.viz} the viz the bars are being added to
 * @param {object} c the bars config (see below for options)
 */
sonic.area = function (viz, initialConfig) {
    var p = {
        xScale: null,
        yScale: null,
        defaultColors: sonic.colors.colorMap(),
        config: {
            /**
             * Type of area chart - basic vs. stacked
             */
            type: 'basic', //or stacked
            /**
             * How should the line that makes the edge of the area be interpolated
             */
            interpolator: 'linear', //or basis
            /**
             * How should the stack be calculated.  See d3 docs for more info
             */
            offset: 'zero', //org silhouette, wiggle, expand, or function
            /**
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * Set of css classes to add to the bars
             */
            cls: '',
            /**
             * The field that makes each data point unique
             */
            definedDataKey: 'id',
            /**
             * The field that each data point uses for its x-axis value
             */
            xDataKey: 'x',
            /**
             * The field that each data point uses for its y-axis value
             */
            yDataKey: 'y',
            /**
             * Which scale (by id) to use for the x-axis.  Can be passed in, otherwise
             * auto-generated based on xDataKey
             */
            xScaleId: null,
            /**
             * Which scale (by id) to use for the y-axis.  Can be passed in, otherwise
             * auto-generated based on yDataKey
             */
            yScaleId: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component
             *
             * e.g. "bestKey", ["bestKey"], ["bestKey", "worstKey"]
             */
            seriesKeys: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component, based off of
             * the index of the series in the viz data
             *
             * e.g. 1, [1], [1, 3]
             */
            seriesIndexes: null,
            /**
             * Stroke color
             * Note: Will use series colors instead from data if they are defined
             */
            stroke: 'black',
            /**
             * Fill color
             * Note: Will use series colors instead from data if they are defined
             */
            fill: null,
            /**
             * Starting fill color
             */
            startingFill: '#FFF',
            /**
             * Whether to sort the data before rendering
             */
            sort: false,
            /**
             * Controls animation of bars. Duration controls how long it takes to update
             * a bar. Delay when null will update left --> right, otherwise it will update all
             * at once.
             */
            animation: {
                duration: null,
                delay: null
            },
            /** Stroke (border) width */
            strokeWidth: 1,
            /** Fill opacity */
            fillOpacity: 1,
            /** Tooltip config */
            tooltip: {
                /**
                 * Only show the tooltip if closest point is within a certain
                 * buffer area - can be by value, or by pixel
                 */
                buffer: {
                    type: 'value', //or pixel
                    amount: null //value, or px amount
                },
                /**
                 * Custom function to render the tooltips
                 *
                 * @param {Object...} Array of closest point objects which
                 * has the closest point, the distance to the mouse, and the
                 * series information
                 * @param {Number...} Mouse position in form [x, y]
                 * @return {String} html
                 */
                renderFn: null
            }
        }
    };

    /**
     * Area constructor renders areas
     *
     * @param {d3.selection} sel where to render the areas to
     * @param {Object} opts extra information on how to render the areas
     *   generally used to specify custom transitions
     */
    function area(sel, opts) {
        var classes = [p.config.cls, 'sonic-area', area.id()],
            groups;

        //update this bar instance's selection to match the current one
        p.selection = sel;

        p.computeData(opts || {});
        p.setScales();

        //group for each series
        groups = sel.selectAll(classes.join('.'))
            .data(p.data, function (s) {
                return s.key;
            });

        //create groups for any new series
        groups.enter().insert('g')
            .classed(classes.join(' '), true)
            .append('path')
                .attr('fill', p.config.startingFill);

        //for each group, draw areas
        groups.each(p.drawAreas);

        groups.each(p.setupLegend);

        //remove old series
        groups.exit().remove();

        //Since we attempted to draw areas, we alert the viz
        //if we were successful or not
        viz.registerVisibleContent(area, area.hasContent());
    }

    /**
     * Compute the data based off viz.data() array
     */
    p.computeData = function (opts) {
        p.data = [];
        if (opts.remove) {
            return;
        }
        p.data = viz.dataBySeries(p.config.seriesKeys, p.config.seriesIndexes);

        if (p.data.length === 0) {
            return;
        }

        if (p.config.type === 'stacked') {
            p.computeStackedData();
        }

        /** Used for default colors - @todo probably a better way */
        p.data.forEach(function (s, i) {
            s.index = i;
        });
    };

    /**
     * Compute the data for a stacked area chart, which basically adds a
     * y0 value onto each data point.  Because of this, make sure to
     * clone viz.data() since using stack is destructive
     *
     * Stack layout expects equal number of values per series, so this
     * "fills in" the values arrays for each series so the length is equal.
     * Each point has a value of 0, and a filler=true variable so that it
     * can be ignored in other parts of this code. It also expects the
     * values array to be sorted the same way between series
     *
     * Note: Requires computeData to be called first
     */
    p.computeStackedData = function () {
        var uniqueXVals,
            stack;

        //create stack
        stack = d3.layout.stack()
            .values(function (d) {
                return d.values;
            })
            .x(function (d) { return d[p.config.xDataKey]; })
            .y(function (d) { return d[p.config.yDataKey]; })
            .offset(p.config.offset);

        //get unique x values amongst data
        uniqueXVals = sonic.array.unique(p.data.map(function (s) {
            return s.values.map(function (d) {
                return d[p.config.xDataKey];
            });
        }));

        //fill in values arrays & sort for each series to be same
        //length before stack (stack layout requires these conditions)
        p.data = sonic.clone(p.data).map(function (s) {
            uniqueXVals.forEach(function (k) {
                var pt = {};

                if (!sonic.array.contains(
                        sonic.array.pluck(s.values, p.config.xDataKey),
                        k
                    )) {

                    pt[p.config.xDataKey] = k;
                    pt[p.config.yDataKey] = 0;
                    pt.filler = true; //labeled so not shown later on
                    s.values.push(pt);
                }
            });

            s.values.sort(sonic.sortByProp(p.config.xDataKey));
            return s;
        });

        //do the stack
        p.data = stack(p.data);
    };

    /**
     * Sets the x and y scales for this instance  If an actual scale
     * passed in, uses that.  If a scale id passed in, use it,
     * otherwise find the appropiate scale from the datakey.
     */
    p.setScales = function () {
        if (sonic.isSet(p.config.xScale)) {
            p.xScale = p.config.xScale;
            p.config.xScaleId = viz.register('scale', p.xScale);
            delete p.config.xScale;
        } else {
            if (p.config.xScaleId) {
                p.xScale = viz.findOne('scale', p.config.xScaleId);
            } else {
                p.xScale = viz.findOne('scale', { dataKey: p.config.xDataKey });
                p.config.xScaleId = p.xScale.id();
            }
        }

        if (sonic.isSet(p.config.yScale)) {
            p.yScale = p.config.yScale;
            p.config.yScaleId = viz.register('scale', p.yScale);
            delete p.config.yScale;
        } else {
            if (p.config.yScaleId) {
                p.yScale = viz.findOne('scale', p.config.yScaleId);
            } else {
                p.yScale = viz.findOne('scale', { dataKey: p.config.yDataKey });
                p.config.yScaleId = p.yScale.id();
            }
        }

        //since the stacked chart aggregates data points together, need
        //to update the scale/axis to fit the aggregate values
        if (p.config.type === 'stacked') {
            p.transitionAxisToStacked();
        } else {
            p.transitionAxisToBasic();
        }
    };

    /**
     * Transition axis to stacked
     *
     * Determines new domain max by looping through values
     * and adding y0 to y value
     */
    p.transitionAxisToStacked = function () {
        var oldMin = p.yScale.domainMin(),
            oldMax = p.yScale.domainMax();

        if (p.data.length === 0) {
            return;
        }

        p.yScale.domainMin(d3.min(p.data, function (s) {
            return d3.min(s.values, function (d) {
                return d.y0;
            });
        }));

        p.yScale.domainMax(d3.max(p.data, function (s) {
            return d3.max(s.values, function (d) {
                return d.y0 + d[p.config.yDataKey];
            });
        }));

        if (p.yScale.domainMax() !== oldMax || p.yScale.domainMin() !== oldMin) {
            viz.refreshRegistry(area.id());
        }
    };

    /**
     * Transitions axis to basic
     *
     * Only uses the y value to determine the domain max
     *
     * TODO Figure out way to include pin-to in domain setting
     * right now, this won't work quite right for non-zero based
     * axes
     */
    p.transitionAxisToBasic = function () {
        /*
        p.yScale.domainMin(d3.min(data, function (s) {
            return d3.min(s.values, function (d) {
                return d[config.yDataKey];
            });
        }));
        */
        var oldMax = p.yScale.domainMax();
        p.yScale.domainMax(d3.max(p.data, function (s) {
            return d3.max(s.values, function (d) {
                return d[p.config.yDataKey];
            });
        }));
        if (oldMax !== p.yScale.domainMax()) {
            viz.refreshRegistry(area.id());
        }
    };

    p.setupLegend = function (series, i, opts) {
        d3.select(this).selectAll('path')
            .attr(area.id() + '-data-legend', function () {
                return series.name || series.key;
            });
    };

    /**
     * Draw the areas for each series
     *
     * @param {Object} series object
     * @param {Number} i index of series
     * @param {Object} opts Options for how to render the bars
     */
    p.drawAreas = function (series, i, opts) {
        var areaGen = p.areaGenerator();

        d3.select(this).selectAll('path')
            .data(p.data)
            .transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('fill', function (d, i) {
                return p.getFillColor.call(this, d, i, series);
            })
            .attr('fill-opacity', p.config.fillOpacity)
            .attr('stroke', function (d, i) {
                var color = p.getFillColor.call(this, d, i, series);
                if (color) {
                    color = d3.rgb(color).darker();
                }
                return color;
            })
            .attr('stroke-width', p.config.strokeWidth)
            .attr('d', function (d) {
                var vals = series.values;
                if (p.config.sort) {
                    vals = p.xScale.sort(vals);
                }
                return areaGen(vals);
            });
    };

    /**
     * Getnerate the area path - note that if stacked, need to take
     * into account y0 value
     */
    p.areaGenerator = function () {
        return d3.svg.area()
            .interpolate(p.config.interpolator)
            .x(function (d) {
                return p.xScale.position(d[p.config.xDataKey]);
            })
            .y0(function (d) {
                return p.config.type === 'stacked' ?
                        p.yScale.position(d.y0) : p.yScale.position(p.yScale.domainMin());
            })
            .y1(function (d) {
                return p.config.type === 'stacked' ?
                        p.yScale.position(d.y0 + d[p.config.yDataKey]) :
                        p.yScale.position(d[p.config.yDataKey]);
            });
    };

    /**
     * Get fill color for area - first tries series color, then
     * the default color for the specified index
     */
    p.getFillColor = function (d, i, series) {
        return series.color || p.config.fill || p.defaultColors(series.index);
    };

    /**
     * On viz mouse move, find closest points
     * and update tooltips accordingly
     */
    p.onVizMouseMove = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        p.updateTooltips(mouse, cps);

        return cps;
    };

    /*
     * On viz mouse click, find closest points
     * and return them
     */
    p.onVizClick = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        return cps;
    };

    /**
     * Find closest points to mouse
     */
    p.closestPoints = function (mouse) {
        var cps = [],
            inRange,
            noConfig,
            x = mouse[0],
            y = mouse[1];

        if (sonic.isSet(p.config.tooltip.buffer.value) === true) {
            inRange = (y >= p.yScale.rangeMin() && y <= p.yScale.rangeMax());
            if (inRange === false) {
                return [];
            }
        } else {
            noConfig = true;
        }

        if (inRange || noConfig) {
            cps = p.data.map(function (d) {
                var cp = {
                    dist: null,
                    point: null
                };

                sonic.each(d, function (k,v) {
                    if (k !== 'values') {
                        cp[k] = v;
                    }
                });

                return cp;
            });

            p.data.forEach(function (d, i) {
                d.values.forEach(function (v) {
                    var dist = Math.abs(p.xScale.position(v[p.config.xDataKey], 'center') - x);

                    //if a filler object (just used to fill out the stack layout), ignore
                    if (v.filler) {
                        return;
                    }

                    if (!cps[i].point || dist < cps[i].dist) {
                        //check to make sure point is within buffer before
                        //considering it actually a close point
                        if (p.pointWithinBuffer(v, dist)) {
                            cps[i].point = v;
                            cps[i].dist = dist;
                        }
                    }
                });
            });

            //if no closest points in a series, don't return that series
            cps = cps.filter(function (d) {
                return (sonic.isSet(d.point)) ? true : false;
            });
        }

        return cps;
    };

    /**
     * Is the point, alongside its px distance within the buffer?
     *
     * Can use value, or pixel as buffer
     */
    p.pointWithinBuffer = function (point, pxDistance) {
        var withinBuffer = true;

        if (sonic.isSet(p.config.tooltip.buffer.amount)) {
            if (p.config.tooltip.buffer.type === 'value') {
                if (p.xScale.domainRangeToInterval(pxDistance) >
                        p.config.tooltip.buffer.amount) {
                    withinBuffer = false;
                }
            } else {
                if (pxDistance > p.config.tooltip.buffer.amount) {
                    withinBuffer = false;
                }
            }
        }

        return withinBuffer;
    };

    /**
     * Update tooltips
     */
    p.updateTooltips = function (mouse, cps) {
        var content,
            renderFn = p.config.tooltip.renderFn || p.renderTooltips;

        if (p.config.tooltip) {
            if (mouse && cps.length > 0) {
                p.config.tooltip.closestPoints = cps;
                p.config.tooltip.content = renderFn(cps, mouse);
                p.config.tooltip.associatedId = area.id();
                p.config.tooltip.mouse = mouse;

                viz.showTooltip(p.config.tooltip);
            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    /**
     * Default render tooltip function
     */
    p.renderTooltips = function (cps, mouse) {
        return cps.map(function (cp) {
            var html = '<p>';
            if (cps.length > 1 || (p.config.tooltip && p.config.tooltip.type === 'global')) {
                html = html + '<b><u>' + cp.key + '</u></b><br />';
            }

            html = html + '<b>' + p.config.xDataKey + ':</b>' + cp.point[p.config.xDataKey] + '<br />' +
                '<b>' + p.config.yDataKey + ':</b>' + cp.point[p.config.yDataKey];

            return html + '</p>';
        }).reduce(function (last, curr) {
            return last + curr;
        });
    };

    /**
     * Make the network registerable and listenable
     */
    sonic.augment(area, p, viz, 'registerable', 'listenable');

    //merge config
    area.mergeConfig(initialConfig);

    //register this area
    viz.register('sonic-area', area);

    return area;
};

//add new area instance
function sonic_area_add (v, c) {
    v.body().call(sonic.area(v, c));
}

//update existing bar instances
function sonic_area_update (v, p, c) {
    v.find('sonic-area', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

function sonic_area_remove (v, c) {
    v.remove('sonic-area', c);
}

/* Public API Methods */
sonic_api.add('addArea', sonic_area_add);
sonic_api.add('addAreas', sonic_area_add);
sonic_api.add('removeAreas', sonic_area_remove);
sonic_api.add('updateAreas', sonic_area_update);
