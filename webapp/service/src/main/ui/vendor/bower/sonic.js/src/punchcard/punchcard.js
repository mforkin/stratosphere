/**
 * Adds a punchcard to the chart
 * @param {Object} config - The configuration for drawing the punchcard. Options include:
 {
    id: String A unique id for the punchcard card, is autogenerated if not specified
    cls: String additional css classes to apply to the punchcard
    definedDataKey: the unique identifier field for the datapoint, used for the radius of circles
    xDataKey: the x field for the datapoint
    xScaleKey: the xScale to use
    yDataKey: the y field for the datapoint
    yScaleKey: the y scale field to use
    fill: the color of the circles
    fillOpacity: the opacity of the circles
    duration: number of milliseconds for the duration of the transition
    radiusMultiplier: the number to multiply the computed radius by, to make the circles larger
    zeroRadius: the radius of circles with a count of '0'
 */
sonic.punchcard = function (viz, initialConfig) {
    var p = {
        xScale: null,
        yScale: null,
        min: null,
        max: null,
        config: {
            id: null,
            cls: '',
            xDataKey: 'x',
            yDataKey: 'y',
            zDataKey: 'z',
            xScaleId: null,
            yScaleId: null,
            stroke: initialConfig && initialConfig.fill && !initialConfig.stroke ? initialConfig.fill : 'black',
            fill: initialConfig && initialConfig.stroke && !initialConfig.fill ? initialConfig.stroke : 'black',
            fillOpacity: 1,
            radius: [2, 10],
            clickable: true,
            tooltip: {
                buffer: null,
                type: 'grouped'
            }
        }
    };

    function punchcard(sel, opts) {
        var classes = [p.config.cls, 'sonic-punchcard'],
            groups,
            punches;

        p.selection = sel;

        p.computeData(opts || {});
        p.setScales();

        groups = sel.selectAll('.sonic-punchcard.' + punchcard.id())
            .data(p.data, function (d) {
                return d.key;
            });

        groups.enter().append('g')
            .classed('sonic-punchcard ' + punchcard.id(), true);

        groups.each(p.drawPunches);

        groups.exit().remove();

        //Since we just tried to draw a punchcard, we ask the viz to check
        //its content to update the no data message appropriately
        viz.registerVisibleContent(punchcard, punchcard.hasContent());
    }

    punchcard.hasContent = sonic.override(function () {
        var hasContent = false;

        if (p.data.length > 0) {
            p.data.forEach(function (k) {
                if (k.values.length > 0) {
                    hasContent = true;
                    return;
                }
            }, this);
        }

        return hasContent;
    });

    p.onVizMouseMove = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        p.updateTooltips(mouse, cps);

        p.selection.selectAll('circle:not(.selected)')
            .classed('hovered', function (d, i) {
                return sonic.isSet(cps) ? p.isClosestPoint(d, cps) : false;
            })
            .attr('fill', p.getPunchFill)
            .attr('stroke', function () {
                return d3.rgb(p.getPunchFill.apply(this, arguments)).darker();
            });

        return cps;
    };

    p.onVizClick = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        if (p.config.clickable) {
            p.selection.selectAll('circle')
                .classed('selected', function (d, i) {
                    return sonic.isSet(cps) ? p.isClosestPoint(d, cps) : false;
                })
                .classed('hovered', false)
                .attr('fill', p.getPunchFill)
                .attr('stroke', function () {
                    return d3.rgb(p.getPunchFill.apply(this, arguments)).darker();
                });
        }

        return cps;
    };

    p.closestPoints = function (mouse) {
        var cps,
            x = mouse[0],
            y = mouse[1];

        cps = p.data.map(function (d) {
            return {
                key: d.key,
                dist: null,
                point: null
            };
        });

        p.data.forEach(function (s, i) {
            s.values.forEach(function (d) {
                var curDistX,
                    curDistY,
                    curDist;

                curDistX = p.xScale.position(d[p.config.xDataKey]) +
                        (p.xScale.type() === 'ordinal' ? p.xScale.rangeBand() / 2 : 0) - x;
                curDistY = p.yScale.position(d[p.config.yDataKey]) +
                        (p.yScale.type() === 'ordinal' ? p.yScale.rangeBand() / 2 : 0) - y;
                curDist = Math.sqrt(curDistX * curDistX + curDistY * curDistY);

                if (!cps[i].point || curDist < cps[i].dist) {
                    cps[i].point = d;
                    cps[i].dist = curDist;
                }
            });
        });

        cps = cps.reduce(function (totalCps, cpCandidate) {
            if ((totalCps.length === 0 || cpCandidate.dist < totalCps[0].dist) && sonic.isSet(cpCandidate.point)) {
                return [cpCandidate];
            }
            return totalCps;
        }, []);

        return cps;
    };

    p.setScales = function () {
        if (sonic.isSet(p.config.xScale)) {
            p.xScale = p.config.xScale;
            p.config.xScaleId = viz.register('scale', p.xScale);
            delete p.config.xScale;
        } else {
            if (p.config.xScaleId) {
                p.xScale = viz.findOne('scale', p.config.xScaleId);
            } else {
                p.xScale = viz.findOne('scale', { dataKey: p.config.xDataKey });
                p.config.xScaleId = p.xScale.id();
            }
        }

        if (sonic.isSet(p.config.yScale)) {
            p.yScale = p.config.yScale;
            p.config.yScaleId = viz.register('scale', p.yScale);
            delete p.config.yScale;
        } else {
            if (p.config.yScaleId) {
                p.yScale = viz.findOne('scale', p.config.yScaleId);
            } else {
                p.yScale = viz.findOne('scale', { dataKey: p.config.yDataKey });
                p.config.yScaleId = p.yScale.id();
            }
        }
    };

    p.computeData = function (opts) {
        p.data = [];
        if (opts.remove) {
            return;
        }
        p.data = p.aggregateDuplicates();
        p.calcExtrema();
    };

    p.aggregateDuplicates = function () {
        var keyNames =[], m = {}, vData = viz.data();
        vData.forEach(function (seriesObj) {
            keyNames.push(seriesObj.key);
            seriesObj.values.forEach(function (point) {
                var lookup = point[p.config.xDataKey] + "-" + point[p.config.yDataKey];
                if (!m[lookup]) {
                    m[lookup] = point;
                } else {
                    m[lookup][p.config.zDataKey] = m[lookup][p.config.zDataKey] + point[p.config.zDataKey];
                }
            });
        });
        return [{
            key: "aggregated:" + keyNames.join("-"),
            values: Object.keys(m).map(function (key) {
                return m[key];
            })
        }];
    };

    p.calcExtrema = function () {
        p.min = null;
        p.max = null;
        p.data.forEach(function (seriesObj) {
            seriesObj.values.forEach(function (point) {
                if (!sonic.isSet(p.min) || point[p.config.zDataKey] < p.min) {
                    p.min = point[p.config.zDataKey];
                }
                if (!sonic.isSet(p.max) || point[p.config.zDataKey] > p.max) {
                    p.max = point[p.config.zDataKey];
                }
            });
        });
    };

    p.drawPunches = function (series, i) {
        var punches;

        punches = d3.select(this).selectAll('circle')
            .data(function (d) {
                return d.values;
            }, function (d) {
                return d.id;
            });

        punches.enter().append('circle')
            .attr('r', 0);

        punches
            .transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('fill', p.getPunchFill)
            .attr('fill-opacity', p.config.fillOpacity)
            .attr('cx', function (d) {
                return p.xScale.position(d[p.config.xDataKey]) + (p.xScale.type() === 'ordinal' ? p.xScale.rangeBand() / 2 : 0);
            })
            .attr('cy', function (d) {
                return p.yScale.position(d[p.config.yDataKey]) + (p.yScale.type() === 'ordinal' ? p.yScale.rangeBand() / 2 : 0);
            })
            .attr('stroke', function () {
                return d3.rgb(p.getPunchFill.apply(this, arguments)).darker();
            })
            .attr('r', function (d) {
                var dPercent;
                dPercent = (p.max !== p.min) ? (d[p.config.zDataKey] - p.min) / (p.max - p.min) : 0.5;
                return p.config.radius[0] + (dPercent * (p.config.radius[1] - p.config.radius[0]));
            });

        punches.exit().remove();
    };

    p.updateTooltips = function (mouse, cps) {
        var content,
            renderFn = p.config.tooltip.renderFn || p.renderTooltips;

        if (p.config.tooltip) {
            if (mouse && cps) {
                p.config.tooltip.closestPoint = cps;
                p.config.tooltip.content = renderFn(cps, mouse);
                p.config.tooltip.associatedId = punchcard.id();
                p.config.tooltip.mouse = mouse;

                viz.showTooltip(p.config.tooltip);
            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    p.renderTooltips = function (cps, mouse) {
        if (cps.length === 0) {
            return;
        } else {
            return '<p><b>' + p.config.xDataKey + ': </b>' + cps[0].point[p.config.xDataKey] + '<br />' +
                    '<b>' + p.config.yDataKey + ': </b>' + cps[0].point[p.config.yDataKey] + '<br />' +
                    '<b>' + p.config.zDataKey + ': </b>' + cps[0].point[p.config.zDataKey] + '</p>';
        }
    };

    p.isClosestPoint = function (d, cps) {
        var isClosest = false;

        cps.forEach(function (c) {
            if (c.point && c.point.id === d.id) {
                isClosest = true;
            }
        });

        return isClosest;
    };

    p.getSelected = function (d, i) {
        return sonic.svg.hasClass(this, 'selected');
    };

    p.getHovered = function (d, i) {
        return sonic.svg.hasClass(this, 'hovered');
    };

    /**
     * @todo color should always go with series data, not assume 1 here
     */
    p.getPunchFill = function (d, i) {
        var fill = p.config.fill;

        if (sonic.isSet(p.data[0].color)) {
            fill = p.data[0].color;
        }

        if (sonic.isSet(d.color)) {
            fill = d.color;
        }

        if (p.getSelected.call(this, d, i) || p.getHovered.call(this, d, i)) {
            fill = d3.rgb(fill).brighter(3).toString();
        }

        return fill;
    };

    sonic.augment(punchcard, p, viz, 'registerable', 'listenable');

    punchcard.mergeConfig(initialConfig);

    viz.register('sonic-punchcard', punchcard);

    return punchcard;
};

function sonic_punchcard_add (v, c) {
    v.body().call(sonic.punchcard(v, c));
}

function sonic_punchcard_remove (v, c) {
    v.remove('sonic-punchcard', c);
}

/**
 * Update matching punchcards in viz v, based on params p,
 * to have config c
 */
function sonic_punchcard_update (v, p, c) {
    v.find('sonic-punchcard', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

sonic_api.add('addPunchcard', sonic_punchcard_add);
sonic_api.add('addPunches', sonic_punchcard_add);
sonic_api.add('updatePunchcard', sonic_punchcard_update);
sonic_api.add('updatePunches', sonic_punchcard_update);
sonic_api.add('removePunches', sonic_punchcard_remove);
