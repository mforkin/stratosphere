/**
 * Adds points to the viz.  Useful for scatter plots, or anything really
 *
 * @todo enable click interaction
 * @todo bug when transitioning a symbol's shape/type...known issue in d3
 *
 * @param {sonic.viz} viz the viz the lines are being added to
 * @param {Object} c - the line config (see below for options)
 */
sonic.point = function (viz, initialConfig) {
    var p = {
        xScale: null, //xScale
        yScale: null, //yScale
        defaultColors: sonic.colors.colorMap(), //default colors
        config: {
            /**
             *  Unique id for this set of points
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the point collection by an id that you know
             */
            id: null,
            /**
             * Set of css classes
             */
            cls: '',
            /**
             * The field that makes each data point unique
             */
            definedDataKey: 'id',
            /**
             * The field that each data point uses for its x-axis value
             */
            xDataKey: 'x',
            /**
             * The field that each data point uses for its y-axis value
             */
            yDataKey: 'y',
            /**
             * Which scale (by id) to use for the x-axis.  Can be passed in, otherwise
             * auto-generated based on xDataKey
             */
            xScaleId: null,
            /**
             * Which scale (by id) to use for the y-axis.  Can be passed in, otherwise
             * auto-generated based on yDataKey
             */
            yScaleId: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component
             *
             * e.g. "bestKey", ["bestKey"], ["bestKey", "worstKey"]
             */
            seriesKeys: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component, based off of
             * the index of the series in the viz data
             *
             * e.g. 1, [1], [1, 3]
             */
            seriesIndexes: null,
            /**
             * Stroke color
             *
             * Note: Will use series colors instead from data if they are defined
             */
            stroke: '',
            strokeWidth: 1,
            /**
             * Fill color
             *
             * Note: Will use series colors instead from data if they are defined
             */
            fill: '',
            /**
             * d3 symbol to use to represent points in collection
             *
             * options are: circle, cross, diamond, square, triangle-down, triangle-up
             *
             * @todo allow arbitrary symbols using passed in svg, etc.
             */
            symbol: 'circle',
            /**
             * The pixel squared value (so, in this case 8x8) of the point
             */
            size: 64,
            /**
             * The multiplier of how big the point size should be when highlighted
             */
            highlightSizeScale: 2,
            /** Fill opacity */
            fillOpacity: 1,
            /* determine closest point based on 'x' or 'y' distance only */
            closestPointBy: null,
            /**
             * config for if you want labels on all points
             */
            standardLabel: {
                dx: -1,
                dy: 1,
                show: false,
                labelGenFn: function (dot) {
                    return dot.id;
                }
            },
            /**
             * config for the label you want on the highlighted point
             */
            highlightLabel: {
                dx: -3.5,
                dy: 3.3,
                show: false,
                textColor: '#000000',
                bkgrdColor: '#ffffff',
                labelGenFn: function (dot) {
                    return dot.id;
                }
            },
            /** Tooltip config */
            tooltip: {
                /**
                 * Only show the tooltip if closest point is within a certain
                 * buffer area - can be by value, or by pixel
                 */
                buffer: {
                    type: 'value', //value, pixel, or radius
                    amount: null //value, or px amount
                },
                /**
                 * Custom function to render the tooltips
                 *
                 * @param {Object...} Array of closest point objects which
                 * has the closest point, the distance to the mouse, and the
                 * series information
                 * @param {Number...} Mouse position in form [x, y]
                 * @return {String} html
                 */
                renderFn: null
            },
            zoom: false
        }
    };

    /**
     * Point constructor renders the point(s)
     *
     * @param {d3.selection} sel where to render to
     * @param {Object} opts extra information on how to render
     *   generally used to specify custom transitions
     */
    function point(sel, opts) {
        var classes = [p.config.cls, 'sonic-point-set', point.id()],
            groups;

        //update this line instance's selection to match the current one
        p.selection = sel;

        p.computeData();
        p.setScales();

        //group for each series
        groups = sel.selectAll(classes.join('.'))
            .data(p.data, function (d) {
                return d.key;
            });

        //create groups for any new series
        groups.enter().append('g')
            .classed(classes.join(' '), true);

        groups.each(p.drawPoints);

        groups.each(p.setupLegend);

        groups.exit().remove();

        if (p.config.zoom) {
            p.addZoom(opts);
        }

        viz.registerVisibleContent(point, point.hasContent());
    }

    p.addZoom = function (opts) {
        viz.addZoom(
            point.id(),
            {
                zoom: {
                    opts: opts,
                    fn: p.zoomAction
                }
            },
            p.xScale,
            p.yScale
        );
    };

    p.zoomAction = function (opts) {
        //this might be inefficient with larger datasets. Maybe consider
        //translating and scaling directly rather than calling point.
        point(p.selection, opts);
    };

    /**
     * Compute this instance's data from the viz data, using the passed
     * in series keys or indexes
     */
    p.computeData = function (opts) {
        opts = opts || {};
        p.data = [];

        if (opts.remove) {
            return;
        }
        p.data = sonic.clone(viz.dataBySeries(p.config.seriesKeys, p.config.seriesIndexes));

        /** Used for default colors - @todo probably a better way */

        p.data.forEach(function (s, i) {
            s.index = i;
            s.values = s.values.filter(function (d) {
                if (p.xScale && p.yScale && p.config.zoom) {
                    return !(d[p.config.xDataKey] < p.xScale.domain()[0] || d[p.config.xDataKey] > p.xScale.domain()[1] || d[p.config.yDataKey] < p.yScale.domain()[0] || d[p.config.yDataKey] > p.yScale.domain()[1]);
                } else {
                    return true;
                }
            });
        });

    };

    /**
     * Sets the x and y scales for this instance  If an actual scale
     * passed in, uses that.  If a scale id passed in, use it,
     * otherwise find the appropiate scale from the datakey.
     */
    p.setScales = function () {
        if (sonic.isSet(p.config.xScale)) {
            p.xScale = p.config.xScale;
            p.config.xScaleId = viz.register('scale', p.xScale);
            delete p.config.xScale;
        } else {
            if (p.config.xScaleId) {
                p.xScale = viz.findOne('scale', p.config.xScaleId);
            } else {
                p.xScale = viz.findOne('scale', { dataKey: p.config.xDataKey });
                p.config.xScaleId = p.xScale.id();
            }
        }

        if (sonic.isSet(p.config.yScale)) {
            p.yScale = p.config.yScale;
            p.config.yScaleId = viz.register('scale', p.yScale);
            delete p.config.yScale;
        } else {
            if (p.config.yScaleId) {
                p.yScale = viz.findOne('scale', p.config.yScaleId);
            } else {
                p.yScale = viz.findOne('scale', { dataKey: p.config.yDataKey });
                p.config.yScaleId = p.yScale.id();
            }
        }
    };

    /**
     * Compute a point's color
     */
    p.computeColor = function (d, i, series, stroke) {
        return  (stroke && d.stroke) || d.color || series.color || p.defaultColors(series.index);
    };

    /**
     * Symbol generator
     *
     * If passed a list of closest points, will adjust size of point
     * accordingly
     */
    p.symbolGenerator = function (cps) {
        return d3.svg.symbol()
            .type(function (d) {
                return d.type || p.config.type;
            })
            .size(function (d) {
                var size = d.size || p.config.size;
                if (p.isClosestPoint(d, cps)) {
                    size = size * p.config.highlightSizeScale;
                }
                return size;
            });
    };

    /**
     * Draw points for the given line series
     * @TODO transitions for the symbol paths throws errors, but don't break anything
     */
    p.drawPoints = function (series, seriesIndex) {
        var dat = [],
            symGen = p.symbolGenerator(),
            points;

        dat = series.values;

        points = d3.select(this).selectAll('.sonic-point')
            .data(dat, function (d) {
                return d[p.config.definedDataKey];
            });

        points.enter().append('path')
            .classed(point.id() + ' sonic-point', true)
            .attr('fill-opacity', function (d) { return sonic.isSet(d.fillOpacity) ? d.fillOpacity : p.config.fillOpacity; })
            .style('opacity', function (d) { return sonic.isSet(d.opacity) ? d.opacity : 1; })
            .attr('d', 'M0,0');

        points
            .attr('d', symGen)
            .transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('transform', function (d) {
                return 'translate(' +
                    p.xScale.position(d[p.config.xDataKey]) + ',' +
                    p.yScale.position(d[p.config.yDataKey]) + ')';
            })
            .attr('stroke', function (d, i) {
                return p.computeColor.call(this, d, i, series, true);
            })
            .attr('stroke-width', function (d, i) {
                return d.strokeWidth || p.config.strokeWidth;
            })
            .attr('fill', function (d, i) {
                return p.computeColor.call(this, d, i, series);
            })
            .attr('fill-opacity', function (d) { return sonic.isSet(d.fillOpacity) ? d.fillOpacity : p.config.fillOpacity; })
            .style('opacity', function (d) { return sonic.isSet(d.opacity) ? d.opacity : 1; });

        points.sort(function (a, b) {
            if (a.selected && !b.selected) {
                return 1;
            } else if (!a.selected && b.selected) {
                return -1;
            }
            return 0;

        });
        points.exit().remove();
    };

    p.setupLegend = function (series, i, opts) {
        d3.select(this).selectAll('path')
            .attr(point.id() + '-data-legend', function () {
                return series.name || series.key;
            });
    };

    /**
     * draw labels on top of symbols, so, like, a number inside a circle
     */
    p.drawLabel = function (dots, type) {
        var label;

        label = d3.select(this).selectAll('.symLabel')
            .data(dots, function (d) {
                return d.point[p.config.definedDataKey];
            });

        label.enter().append('text')
            .classed(point.id() + ' symLabel', true);

        label.attr('transform', function (d) {
                return 'translate(' +
                    p.xScale.position(d.point[p.config.xDataKey]) + ',' +
                    p.yScale.position(d.point[p.config.yDataKey]) + ')';
            })
            .attr('dx', function (d) {
                return p.config[type].dx * d.point.markerId.toString().length;
            })
            .attr('dy', p.config[type].dy)
            .text(function (d) {
                return p.config[type].labelGenFn(d.point);
            })
            .style('fill', function (d) {
                return p.config.highlightLabel.textColor;
            });

        label.exit().remove();
    };

    /**
     * On viz mouse move, find closest points
     * and update tooltips accordingly
     */
    p.onVizMouseMove = function (mouse) {
        var cps,
            pointSets,
            symGen;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        symGen = p.symbolGenerator(cps);

        p.updateTooltips(mouse, cps);

        pointSets = d3.selectAll('.' + point.id() + '.sonic-point-set').selectAll('.' + point.id() + ' .sonic-point');

        pointSets.sort(function (a, b) {
                if (p.isClosestPoint(a, cps)) {
                    return 1;
                }
                if (p.isClosestPoint(b, cps)) {
                    return -1;
                }
                return 0;
            })
            .attr('fill', function (d, i) {
                var color,
                    series = d3.select(this.parentElement).data()[0];

                color = p.computeColor.call(this, d, i, series);

                if (p.isClosestPoint(d, cps)) {
                    if (p.config.highlightLabel.show) {
                        color = p.config.highlightLabel.bkgrdColor;
                    } else {
                        color = d3.rgb(color).brighter().brighter().toString();
                    }
                }

                return color;
            })
            .attr('d', symGen);

        if (p.config.highlightLabel.show) {
            if (cps) {
                pointSets.forEach(function(v, i) {
                    p.drawLabel.call(v.parentNode, [cps[i]], 'highlightLabel');
                }, this);
            } else {
                d3.selectAll('.symLabel').remove();
            }
        }

        return cps;
    };

    /*
     * On viz mouse click, find closest points,
     * update tracer to put the click tracer there,
     * and then return them
     */
    p.onVizClick = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        p.selection.selectAll('.sonic-point')
            .classed('selected', function (d, i) {
                return p.isClosestPoint(d, cps);
            });

        return cps;
    };

    /**
     * Find closest points to mouse.
     * Note changes: will only be a valid closestPoint if within the yScale of the viz.
     */
    p.closestPoints = function (mouse) {
        var cps,
            inRange,
            noConfig,
            x = mouse[0],
            y = mouse[1];

        if(sonic.isSet(p.config.tooltip) && sonic.isSet(p.config.tooltip.buffer) && sonic.isSet(p.config.tooltip.buffer.value) === true) {
            inRange = (y >= p.yScale.rangeMin() && y <= p.yScale.rangeMax());
            if (inRange === false) {
                return [];
            }
        } else {
            noConfig = true;
        }

        if (inRange || noConfig) {
            cps = p.data.map(function (d) {
                return {
                    key: d.key,
                    dist: null,
                    point: null
                };
            });

            p.data.forEach(function (d, i) {
                d.values.forEach(function (v) {
                    var dist,
                        xDist,
                        yDist;

                    xDist = Math.abs(p.xScale.position(v[p.config.xDataKey], 'center') - x);
                    yDist = Math.abs(p.yScale.position(v[p.config.yDataKey], 'center') - y);
                    if (p.config.closestPointBy === 'x') {
                        dist = xDist;
                    } else if (p.config.closestPointBy === 'y') {
                        dist = yDist;
                    } else {
                        dist = sonic.geom.pythagorize(xDist, yDist);
                    }

                    if (!cps[i].point || dist < cps[i].dist) {
                        //check to make sure point is within buffer before
                        //considering it actually a close point
                        if (p.pointWithinBuffer(v, dist)) {
                            cps[i].point = v;
                            cps[i].dist = dist;
                        }
                    }
                });
            });

            //if no closest points in a series, don't return that series
            cps = cps.filter(function (d) {
                return (sonic.isSet(d.point)) ? true : false;
            });

            return cps;
        }
    };

    /**
     * Is the current point one of the closest points that has been
     * identified elsewhere
     */
    p.isClosestPoint = function (d, closestPoints) {
        if (!sonic.isArray(closestPoints)) {
            return false;
        }

        return closestPoints.filter(function (cp) {
            return cp.point[p.config.definedDataKey] === d[p.config.definedDataKey];
        }).length > 0;
    };

    /**
     * Update tooltips
     */
    p.updateTooltips = function (mouse, cps) {
        var content,
            renderFn = p.config.tooltip.renderFn || p.renderTooltips;

        if (p.config.tooltip) {
            p.config.tooltip.associatedId = point.id();
            if (mouse) {
                if (cps.length > 0) {
                    p.config.tooltip.closestPoints = cps;
                    p.config.tooltip.content = renderFn(cps, mouse);
                    p.config.tooltip.mouse = mouse;
                    viz.showTooltip(p.config.tooltip);
                } else {
                    viz.removeTooltip(p.config.tooltip);
                }
            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    /**
     * Default render tooltip function
     */
    p.renderTooltips = function (cps, mouse) {
        return cps.map(function (cp) {
            var html = '<p>';
            if (cps.length > 1 || (p.config.tooltip && p.config.tooltip.type === 'global')) {
                html = html + '<b><u>' + cp.key + '</u></b><br />';
            }

            html = html + '<b>' + p.config.xDataKey + ':</b>' + cp.point[p.config.xDataKey] + '<br />' +
                '<b>' + p.config.yDataKey + ':</b>' + cp.point[p.config.yDataKey];

            return html + '</p>';
        }).reduce(function (last, curr) {
            return last + curr;
        });
    };

    /**
     * Is the point, alongside its px distance within the buffer?
     *
     * Can use value, or pixel as buffer
     */
    p.pointWithinBuffer = function (point, pxDistance) {
        var withinBuffer = true,
            radius = Math.sqrt(point.size || p.config.size) / 2;

        if (sonic.isSet(p.config.tooltip) && sonic.isSet(p.config.tooltip.buffer) && sonic.isSet(p.config.tooltip.buffer.amount)) {
            if (p.config.tooltip.buffer.type === 'value') {
                if (p.xScale.domainRangeToInterval(pxDistance) >
                        p.config.tooltip.buffer.amount) {
                    withinBuffer = false;
                }
            } else {
                if (pxDistance > p.config.tooltip.buffer.amount) {
                    withinBuffer = false;
                }
            }
        } else if (sonic.isSet(p.config.tooltip) && sonic.isSet(p.config.tooltip.buffer) && p.config.tooltip.buffer.type === 'radius') {
            if (pxDistance > radius) {
                withinBuffer = false;
            }
        }

        return withinBuffer;
    };

    point.updatePoint = function (dp) {
        var pt = p.selection.selectAll('.sonic-point')
            .filter(function (d) { return d.id === dp.id; }),
            symGen = p.symbolGenerator(),
            series;

        pt.data().forEach(function (d) { sonic.object.merge(d, dp); });

        viz.dataBySeries(p.config.seriesKeys, p.config.seriesIndexes).forEach(function (s) {
            series = s;
            s.values
                .filter(function(d) { return d.id === dp.id; })
                .forEach(function (d) {
                    sonic.object.merge(d, dp);
                });
        });

        pt
            .attr('d', symGen)
            .transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('transform', function (d) {
                return 'translate(' +
                    p.xScale.position(d[p.config.xDataKey]) + ',' +
                    p.yScale.position(d[p.config.yDataKey]) + ')';
            })
            .attr('stroke', function (d, i) {
                return p.computeColor.call(this, d, i, series, true);
            })
            .attr('stroke-width', function (d, i) {
                return d.strokeWidth || p.config.strokeWidth;
            })
            .attr('fill', function (d, i) {
                return p.computeColor.call(this, d, i, series);
            })
            .attr('fill-opacity', function (d) { return sonic.isSet(d.fillOpacity) ? d.fillOpacity : p.config.fillOpacity; })
            .style('opacity', function (d) { return sonic.isSet(d.opacity) ? d.opacity : 1; });
    };

    sonic.augment(point, p, viz, 'registerable', 'listenable');
    //merge config
    point.mergeConfig(initialConfig);
    //register this point
    viz.register('sonic-point', point);

    return point;
};

/**
 * Add a point or collection of points to the viz body
 *
 * @todo ability to pass 1 point, and it be converted
 * into correct form
 */
function sonic_point_add(v, c) {
    v.body().call(sonic.point(v, c));
}


/**
 * Remove points from the viz body
 */
function sonic_point_remove(v, c) {
    v.remove('sonic-point', c);
}

/**
 * Update matching points in viz v, based on params p,
 * to have config c
 */
function sonic_point_update(v, p, c) {
    v.find('sonic-point', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

function sonic_point_update_single(v, p, pt) {
    v.find('sonic-point', p).forEach(function (cmp) {
        cmp.updatePoint(pt);
    });
}

/* Public API Methods */
sonic_api.add('addPoint', sonic_point_add);
sonic_api.add('addPoints', sonic_point_add);
sonic_api.add('updatePoint', sonic_point_update);
sonic_api.add('updatePoints', sonic_point_update);
sonic_api.add('removePoint', sonic_point_remove);
sonic_api.add('removePoints', sonic_point_remove);
sonic_api.add('updateSinglePoint', sonic_point_update_single);
