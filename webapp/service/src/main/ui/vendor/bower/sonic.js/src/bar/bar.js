/**
 * Adds bars to the viz.  Can be used to show individual bars, or bar groups.
 * Bar groups can be side by side, or stacked
 *
 * @todo right now is just vertical, upwards bars - allow vertical downwards
 *      and both horizontal directions
 *
 * @param {sonic.viz} the viz the bars are being added to
 * @param {object} c the bars config (see below for options)
 */
sonic.bar = function (viz, initialConfig) {
    var p = {
        xScale: null,
        yScale: null,
        barGroupWidth: null,
        barWidth: null,
        groupIndex: null,
        defaultColors: sonic.colors.colorMap(),
        config: {
            /** Type of bar chart, grouped or stacked */
            type: 'grouped',
            /**
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * Set of css classes to add to the bars
             */
            cls: '',
            /**
             * The field that makes each data point unique
             */
            definedDataKey: 'id',
            /**
             * The field that each data point uses for its x-axis value
             */
            xDataKey: 'x',
            /**
             * The field that each data point uses for its y-axis value
             */
            yDataKey: 'y',
            labelKey: 'label',
            /**
             * Which scale (by id) to use for the x-axis.  Can be passed in, otherwise
             * auto-generated based on xDataKey
             */
            xScaleId: null,
            /**
             * Which scale (by id) to use for the y-axis.  Can be passed in, otherwise
             * auto-generated based on yDataKey
             */
            yScaleId: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component
             *
             * e.g. "bestKey", ["bestKey"], ["bestKey", "worstKey"]
             */
            seriesKeys: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component, based off of
             * the index of the series in the viz data
             *
             * e.g. 1, [1], [1, 3]
             */
            seriesIndexes: null,
            /**
             * Stroke color
             * Note: Will use series colors instead from data if they are defined
             */
            stroke: 'black',
            /**
             * Fill color
             * Note: Will use series colors instead from data if they are defined
             */
            fill: '',
            /**
             * Controls animation of bars. Duration controls how long it takes to update
             * a bar. Delay when null will update left --> right, otherwise it will update all
             * at once.
             */
            animation: {
                duration: null,
                delay: null
            },
            /** Stroke (border) width */
            strokeWidth: 1,
            /** Fill opacity */
            fillOpacity: 1,
            /** bar position */
            barPosition: 'center',
            /** Minimum bar width */
            minBarWidth: 8,
            /** Maximum bar width */
            maxBarWidth: 50,
            /** Manually set bar width */
            barWidth: null,
            /**
             * Padding between bars in bar groups
             */
            barPadding: 0,
            /**
             * Padding between bar groups
             */
            barGroupPadding: 5,
            /** Whether to highlight bars when hovering */
            highlightOnHover: true,
            drawLabels: false,
            labelStyle: {
                fontSize: 10,
                fontFamily: 'arial',
                fill: null,
                stroke: 'none',
                anchor: 'middle'
            },
            /** Tooltip config */
            tooltip: {
                type: 'grouped', //grouped or single. @todo implement single for stacked bars
                /**
                 * Custom function to render the tooltips
                 *
                 * @param {Object...} Array of closest point objects which
                 * has the closest point, the distance to the mouse, and the
                 * series information
                 * @param {Number...} Mouse position in form [x, y]
                 * @return {String} html
                 */
                renderFn: null
            }
        }
    };

    /**
     * Bar constructor renders the bars
     *
     * @param {d3.selection} sel where to render the bars to
     * @param {Object} opts extra information on how to render the bars
     *   generally used to specify custom transitions
     */
    function bar(sel, opts) {
        var classes = [p.config.cls, 'sonic-bar'],
            groups,
            groupAction,
            delay,
            duration;

        //update this bar instance's selection to match the current one
        p.selection = sel;

        p.computeData(opts || {});
        p.setScales();
        p.computeBarWidth();

        //groups are by series key
        groups = sel.selectAll(classes.join('.') + '.' + bar.id())
            .data(p.data, function (s) {
                return s.key;
            });

        //create groups for any new series
        //give them their color
        groups.enter().append('g')
            .classed(classes.join(' ') + ' ' + bar.id(), true);

        delay = sonic.isSet(p.config.animation.delay) ? p.config.animation.delay : viz.animation().delay;
        duration = sonic.isSet(p.config.animation.duration) ? p.config.animation.duration : viz.animation().duration;


        if (delay > 0 || duration > 0) {
            groupAction = groups.transition().delay(delay).duration(duration);
        } else {
            groupAction = groups;
        }

        groupAction
            .attr('stroke', function (d, i) {
                return d3.rgb(p.getBarColor(d, i)).darker().toString();
            })
            .attr('fill', p.getBarColor);

        //for each group, draw bars
        groups.each(function (d, i) {
            p.drawBars.call(this, d, i, opts || {});
        });

        groups.each(p.setupLegend);

        //remove old series
        groups.exit().remove();

        //Since we attempted to draw bars, we alert the viz
        //if we were successful or not
        viz.registerVisibleContent(bar, bar.hasContent());
    }

    /**
     * Compute the data based off viz.data() array
     */
    p.computeData = function (opts) {
        p.data = [];
        if (opts.remove) {
            return;
        }
        p.data = viz.dataBySeries(p.config.seriesKeys, p.config.seriesIndexes);
        p.groupIndex = {};

        if (p.data.length === 0) {
            return;
        }

        //keep track of what bar groups there are since the
        //data itself is grouped by series, not bar group
        p.data.forEach(function (s) {
            s.values.forEach(function (d) {
                if (!p.groupIndex[d[p.config.xDataKey]]) {
                    p.groupIndex[d[p.config.xDataKey]] = [];
                }

                if (p.groupIndex[d[p.config.xDataKey]].indexOf(s.key) === -1) {
                    p.groupIndex[d[p.config.xDataKey]].push(s.key);
                }
            });
        });

        if (p.config.type === 'stacked') {
            p.computeStackedData();
        }
    };

    /**
     * Compute the data for a stacked bar chart, which basically adds a
     * y0 value onto each data point.  Because of this, make sure to
     * clone viz.data() since using stack is destructive
     *
     * Stack layout expects equal number of values per series, so this
     * "fills in" the values arrays for each series so the length is equal.
     * Each point has a value of 0, and a filler=true variable so that it
     * can be ignored in other parts of this code. It also expects the
     * values array to be sorted the same way between series
     *
     * Note: Requires computeData to be called first
     */
    p.computeStackedData = function () {
        var stack = d3.layout.stack()
            .values(function (d) {
                return d.values;
            })
            .x(function (d) { return d[p.config.xDataKey]; })
            .y(function (d) { return d[p.config.yDataKey]; });

        //fill in values arrays & sort for each series to be same
        //length before stack
        p.data = sonic.clone(p.data).map(function (s) {
            d3.keys(p.groupIndex).forEach(function (k) {
                var key = k,
                    pt = {};

                if (sonic.string.isNumeric(key)) {
                    key = parseInt(key, 10);
                }

                if (!s.values.some(function (di) {
                        if (sonic.isDate(di[p.config.xDataKey])) {
                            if (!sonic.isDate(key)) {
                                key = new Date(key);
                            }
                            return di[p.config.xDataKey].getTime() === key.getTime() ? true : false;
                        }
                        return di[p.config.xDataKey] === key ? true : false;
                    })) {

                    pt[p.config.xDataKey] = key;
                    pt[p.config.yDataKey] = 0;
                    pt.filler = true;
                    s.values.push(pt);
                }
            });

            s.values.sort(function (a, b) {
                return a[p.config.xDataKey] < b[p.config.xDataKey] ? -1 : 1;
            });

            return s;
        });

        //do the stack
        p.data = stack(p.data);
    };

    /**
     * Sets the x and y scales for this instance  If an actual scale
     * passed in, uses that.  If a scale id passed in, use it,
     * otherwise find the appropiate scale from the datakey.
     */
    p.setScales = function () {
        if (sonic.isSet(p.config.xScale)) {
            p.xScale = p.config.xScale;
            p.config.xScaleId = viz.register('scale', p.xScale);
            delete p.config.xScale;
        } else {
            if (p.config.xScaleId) {
                p.xScale = viz.findOne('scale', p.config.xScaleId);
            } else {
                p.xScale = viz.findOne('scale', { dataKey: p.config.xDataKey });
                p.config.xScaleId = p.xScale.id();
            }
        }

        if (sonic.isSet(p.config.yScale)) {
            p.yScale = p.config.yScale;
            p.config.yScaleId = viz.register('scale', p.yScale);
            delete p.config.yScale;
        } else {
            if (p.config.yScaleId) {
                p.yScale = viz.findOne('scale', p.config.yScaleId);
            } else {
                p.yScale = viz.findOne('scale', { dataKey: p.config.yDataKey });
                p.config.yScaleId = p.yScale.id();
            }
        }

        //since the stacked chart aggregates data points together, need
        //to update the scale/axis to fit the aggregate values
        if (p.config.type === 'stacked') {
            p.transitionAxisToStacked();
        } else {
            p.transitionAxisToGrouped();
        }
    };

    p.setupLegend = function (series, i) {
        d3.select(this).selectAll('rect')
            .attr(bar.id() + '-data-legend', function (s) {
                return series.name || series.key;
            })
            .attr('data-legend-color', function (s) {
                return series.color || series.stroke || s.color || s.stroke;
            });
    };

    /**
     * Draw the bars for each series
     *
     * @param {Object} series object
     * @param {Number} i index of series
     * @param {Object} opts Options for how to render the bars
     */
    p.drawBars = function (series, i, opts) {
        var bars,
            barsToUpdate,
            delay = p.getBarGroupDelay,
            duration = viz.animation().duration,
            barAction;

        //set up rects from data
        bars = d3.select(this).selectAll('rect')
            .data(
                function (d) {
                    return d.values;
                },
                function (d) {
                    return d[p.config.definedDataKey];
                }
            );

        //determines delay and duration values based on configs
        if (sonic.isSet(p.config.animation.delay)) {
            delay = p.config.animation.delay;
        }
        if (sonic.isSet(p.config.animation.duration)) {
            duration = p.config.animation.duration;
        }

        //add new bars, centered on x position
        //and height of 0 so hidden at bottom of viz
        bars.enter().append('rect')
            .attr('stroke-width', p.config.strokeWidth)
            .attr('fill-opacity', p.config.fillOpacity)
            .attr('x', p.getBarAlignment)
            .attr('width', p.barWidth)
            .attr('y', p.getBarInitY)
            .attr('height', 0)
            .attr('fill', p.getDataPointColor)
            .attr('stroke', p.getDataPointStrokeColor);

        if (delay > 0 || duration > 0) {
            barAction = bars.transition().delay(delay).duration(duration);
        } else {
            barAction = bars;
        }

        if (p.config.type === 'stacked') {
            //load bar groups from left to right and rise vertically
            //if animating from grouped, will set height and y first,
            //then x and width
            //checks for correct configuration of animation first
            barAction
                .attr('fill', p.getDataPointColor)
                .attr('stroke', p.getDataPointStrokeColor)
                .attr('stroke-width', p.config.strokeWidth)
                .attr('fill-opacity', p.config.fillOpacity)
                .attr('y', function (d) {
                    return p.yScale.position(d.y0 + d[p.config.yDataKey], 'center');
                })
                .attr('height', function (d) {
                    return p.yScale.position(d.y0) - p.yScale.position(d.y0 + d[p.config.yDataKey], 'center');
                })
                .transition()
                .attr('x', p.getBarAlignment)
                .attr('width', function (d) {
                    return p.barWidth;
                });

        } else {
            //load bar groups from left to right and fan out from center
            //to the correct bar offset
            //if animating from stacked, will set x and width first, then
            //height and y
            // checks for the correct animation configuration first
            barAction
                .attr('fill', p.getDataPointColor)
                .attr('stroke', p.getDataPointStrokeColor)
                .attr('stroke-width', p.config.strokeWidth)
                .attr('fill-opacity', p.config.fillOpacity)
                .attr('x', function (d, i) {
                    return p.getGroupedBarPosition(d, i, series.key);
                })
                .attr('width', p.barWidth)
                .transition()
                .attr('y', p.getGroupedBarY)
                .attr('height', p.getGroupedBarHeight);
        }

        //transition removed bars down to 0 height and remove
        // checks for the correct animation configuration

        if (!(sonic.isSet(p.config.animation.delay))) {
            delay = viz.animation().delay;
        }

        if (delay > 0 || viz.animation().duration > 0) {
            barAction = bars.exit().transition().delay(delay).duration(viz.animation().duration);
        } else {
            barAction = bars.exit();
        }

        //transition removed bars down to 0 height and remove
        barAction
            .attr('y', function (d) {
                return viz.body().height();
            })
            .attr('height', 0)
            .remove();

        if (p.config.drawLabels !== false) {
            p.drawLabels.call(this, series, i, opts);
        }
    };

    p.getLabelX = function (d, i, series) {
        var pos;

        pos = p.getGroupedBarPosition(d, i, series.key);
        if (p.config.barPosition === 'center' || p.config.barPosition === 'bin') {
            pos = pos + p.barWidth / 2;
        }

        return pos;
    };

    p.getLabelY = function (d, i, series) {
        var pos;

        if (p.config.drawLabels === 'top') {
            pos = p.getGroupedBarY.apply(this, arguments) - 5;
        } else {
            pos = p.getGroupedBarY.apply(this, arguments) + p.getGroupedBarHeight.apply(this, arguments) + 15;
        }

        return pos;
    };

    p.drawLabels = function (series, i, opts) {
        var labels,
            labelAction,
            delay = p.getBarGroupDelay,
            duration = viz.animation().duration;

        labels = d3.select(this).selectAll('.sonic-bar-label')
            .data(
                function (d) {
                    return d.values;
                },
                function (d) {
                    return d[p.config.definedDataKey];
                }
            );

        //determines delay and duration values based on configs
        if (sonic.isSet(p.config.animation.delay)) {
            delay = p.config.animation.delay;
        }
        if (sonic.isSet(p.config.animation.duration)) {
            duration = p.config.animation.duration;
        }

        labels.enter().append('text')
            .classed('sonic-bar-label', true)
            .attr('x', p.getBarAlignment)
            .attr('y', p.getBarInitY);

        if (delay > 0 || duration > 0) {
            labelAction = labels.transition().delay(delay).duration(duration);
        } else {
            labelAction = labels;
        }

        if (p.config.type === 'stacked') {
            //maybe implement, what does this even mean
        } else {
            labelAction
                .attr('x', function (d, i) { return p.getLabelX.call(this, d, i, series); })
                .attr('y', function (d, i) { return p.getLabelY.call(this, d, i, series); })
                .style('fill', p.config.labelStyle.fill)
                .style('stroke', 'none')
                .style('font-size', p.config.labelStyle.fontSize + 'px')
                .style('font-family', p.config.labelStyle.fontFamily)
                .style('text-anchor', p.config.labelStyle.anchor)
                .text(function (d) {
                    return d[p.config.labelKey];
                });

        }

        if (!(sonic.isSet(p.config.animation.delay))) {
            delay = viz.animation().delay;
        }

        if (delay > 0 || viz.animation().duration > 0) {
            labelAction = labels.exit().transition().delay(delay).duration(viz.animation().duration);
        } else {
            labelAction = labels.exit();
        }

        labelAction
            .attr('y', viz.body().height())
            .remove();

    };

    /**
     * Compute bar width
     */
    p.computeBarWidth = function () {
        var numSeries = p.data.length;

        //if ordinal, already have bar group, otherwise, compute
        if (p.xScale.type() === 'ordinal') {
            p.barGroupWidth = p.xScale.rangeBand();
        } else {
            if (sonic.isObject(p.config.barWidth)) {
                p.barGroupWidth = p.xScale.domainIntervalToRange(p.config.barWidth.amount);
            } else {
                p.barGroupWidth = Math.floor(p.xScale.rangeExtent() /
                    (sonic.array.maxLength(p.data) * numSeries));
            }
        }

        //give some bar group buffer
        p.barGroupWidth = p.barGroupWidth - p.config.barGroupPadding * 2;

        //if explicitly set, use it
        if (sonic.isSet(p.config.barWidth)) {
            if (sonic.isObject(p.config.barWidth)) {
                p.barWidth = p.xScale.domainIntervalToRange(p.config.barWidth.amount);
            } else {
                p.barWidth = p.config.barWidth;
            }
        } else if (p.config.type === 'stacked' || numSeries === 1) {
            //if stacked or 1 bar per group, set bar width to group width
            //otherwise, split up bar group
            p.barWidth = p.barGroupWidth;
        } else {
            p.barWidth = Math.floor((p.barGroupWidth -
                (numSeries * p.config.barPadding * 2)) / numSeries);
        }

        //todo this isn't quite right
        //also, what to do if barWidth is < 0?
        if (!sonic.isSet(p.config.barWidth)) {
            if (p.barWidth < p.config.minBarWidth) {
                p.barWidth = p.config.minBarWidth;
            } else if (p.barWidth > p.config.maxBarWidth) {
                p.barWidth = p.config.maxBarWidth;
            }
        }

        if (!sonic.isSet(p.config.tooltip.buffer)) {
            p.config.tooltip.buffer = {
                type: 'pixel',
                value: p.barWidth
            };
        }
    };

    /**
     * Get the current bar color
     *
     * Uses the series color if set, otherwise use default colors
     */
    p.getBarColor = function (d, i) {
        return d.color || p.config.fill || p.defaultColors(i);
    };

    /**
     * Get the current data point's color, otherwise returns undefined which
     * means it'll use the bar series color.
     */
    p.getDataPointColor = function (d, i) {
        return d.color || undefined;
    };

    /**
     * Get the current data point's highlight color, otherwise returns undefined which
     * means it'll use the bar series highlight color.
     */
    p.getDataPointStrokeColor = function (d, i) {
        if (d.stroke) {
            return d.stroke;
        } else if (d.color) {
            return d3.rgb(d.color).darker();
        } else {
            return undefined;
        }
    };

    /**
     * Given a datapoint returns the series it belongs to
     */
    p.getBarSeriesIdx = function (d) {
        var series = 0;
        p.data.forEach(function (s, i) {
            if (s.values.indexOf(d) >= 0) {
                series = i;
            }
        });
        return series;
    };

    /**
     * Get the animation delay for a specific bar group
     *
     * Current effect is that bar groups load from left to right
     */
    p.getBarGroupDelay = function (d, i) {
        var delay = 0,
            idx;

        if (sonic.isSet(p.groupIndex)) {
            idx = d3.keys(p.groupIndex).sort(function (a, b) {
                var aVal = sonic.string.isNumeric(a) ? parseInt(a, 10) : a,
                    bVal = sonic.string.isNumeric(b) ? parseInt(b, 10) : b;
                return p.xScale.position(aVal, p.config.barPosition) <
                    p.xScale.position(bVal, p.config.barPosition) ? -1 : 1;
            }).indexOf(String(d[p.config.xDataKey]));

            if (idx === -1) {
                delay = 0;
            } else {
                delay = idx * 200;
            }
        }

        return delay;
    };

    /**
     * Gets the alignment of the bar, offsets if position is centered
     * @TODO only supports center and left currently
     * also need to put the position adjustment inside the xScale.position function
     * based on the passed barPosition
     */
    p.getBarAlignment = function (d, i) {
        var pos = p.xScale.position(d[p.config.xDataKey], p.config.barPosition);
        if (p.config.barPosition === 'center') {
            pos = pos - p.barWidth / 2;
        }
        return pos;
    };

    /**
     * Get offset of bar within group
     */
    p.getGroupedBarPosition = function (d, i, sKey, location) {
        var gi = p.groupIndex[d[p.config.xDataKey]],
            idx = 0,
            pos = p.xScale.position(d[p.config.xDataKey], p.config.barPosition);

        if (sonic.isSet(gi)) {
            idx = gi.indexOf(sKey);

            if (idx !== -1) {
                pos += idx * (p.barWidth + p.config.barPadding * 2);
                if (p.config.barPosition === 'center') {
                    pos += (-1 * gi.length * (p.barWidth + p.config.barPadding) / 2);
                }
            }
        }

        if (location && location === 'center') {
            pos = pos + (p.barWidth + p.config.barPadding) / 2;
        } else if (location && location === 'max') {
            pos = pos + (p.barWidth + p.config.barPadding * 2);
        }

        return pos;
    };

    p.getGroupedBarY = function (d, i) {
        var baseline = d.y0,
            yVal = d[p.config.yDataKey];

        if (sonic.isSet(baseline)) {
            yVal = Math.max(yVal, baseline);
        }

        return p.yScale.position(yVal, p.config.barPosition);
    };

    p.getBarInitY = function (d, i) {
        var baseline = d.y0,
            yVal = viz.body().height();

        if (sonic.isSet(baseline) &&
                p.config.type === 'grouped') {
            yVal = p.yScale.position(d.y0, p.config.barPosition);
        }

        return yVal;
    };

    p.getGroupedBarHeight = function (d, i) {
        var baseline = d.y0,
            heightVal = viz.body().height(),
            yVal = d[p.config.yDataKey];

        if (sonic.isSet(baseline)) {
            heightVal = p.yScale.position(baseline, p.config.barPosition);
        }

        return Math.abs(p.yScale.position(d[p.config.yDataKey], p.config.barPosition) - heightVal);
    };

    /**
     * Transition axis to stacked
     *
     * Determines new domain max by looping through values
     * and adding y0 to y value
     */
    p.transitionAxisToStacked = function () {
        /*
        yScale.domainMin(d3.min(p.data, function (s) {
            return d3.min(s.values, function (d) {
                return d.y0 + d[p.config.yDataKey];
            });
        }));
        */

        var oldMax = p.yScale.domainMax();
        p.yScale.domainMax(d3.max(p.data, function (s) {
            return d3.max(s.values, function (d) {
                return d.y0 + d[p.config.yDataKey];
            });
        }));

        if (oldMax !== p.yScale.domainMax()) {
            viz.refreshRegistry(bar.id());
        }
    };

    /**
     * Transitions axis to grouped
     *
     * Only uses the y value to determine the domain max
     *
     * TODO Figure out way to include pin-to in domain setting
     * right now, this won't work quite right for non-zero based
     * axes
     */
    p.transitionAxisToGrouped = function () {
        /*
        yScale.domainMin(d3.min(p.data, function (s) {
            return d3.min(s.values, function (d) {
                return d[p.config.yDataKey];
            });
        }));
        */

        var oldMax = p.yScale.domainMax();
        p.yScale.domainMax(d3.max(p.data, function (s) {
            return d3.max(s.values, function (d) {
                return d[p.config.yDataKey];
            });
        }));

        if (oldMax !== p.yScale.domainMax()) {
            viz.refreshRegistry(bar.id());
        }
    };

    /**
     * On viz mouse move, find closest points
     * and update tooltips accordingly
     */
    p.onVizMouseMove = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse, p.config.tooltip.type);
        }

        if (p.config.highlightOnHover) {
            p.selection.selectAll('.' + bar.id() + ' rect')
                .style('fill', function (d, i) {
                    var fill = d.color || d3.select(this.parentNode).attr('fill');
                    return (cps && cps.filter(function (cp) { return d === cp.point;}).length > 0) ? d3.rgb(fill).brighter() : null;
                })
                .attr('stroke-width', function (d, i) {
                    var strokeWidth = p.config.strokeWidth;
                    return (cps && cps.filter(function (cp) {return d === cp.point;}).length > 0) ? strokeWidth + 1 : strokeWidth;
                });
        }

        p.updateTooltips(mouse, cps);

        return cps;
    };

    /*
     * On viz mouse click, find closest points
     * and return them
     */
    p.onVizClick = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        return cps;
    };

    /**
     * Find closest points to mouse
     */
    p.closestPoints = function (mouse, type) {
        var cps,
            closest,
            x = mouse[0],
            y = mouse[1],
            v,
            minX,
            maxX,
            dist,
            ignore;

        cps = p.data.map(function (d) {
            var cp = {
                point: null,
                dist: null
            };

            sonic.each(d, function (k, v) {
                if (k !== 'values') {
                    cp[k] = v;
                }
            });

            return cp;
        });

        p.data.forEach(function (d, i) {
            for (var j = 0; j < d.values.length; j++) {
                v = d.values[j];
                minX = p.xScale.position(v[p.config.xDataKey]);
                maxX = p.xScale.position(v[p.config.xDataKey]) + Math.max(p.barGroupWidth, p.barWidth || 0);
                dist = null;
                ignore = false;

                //if point was used to fill in stack, ignore
                if (p.config.type === 'stacked' && v.filler === true) {
                    ignore = true;
                }

                //within bar group?
                if (!ignore && minX <= x && maxX >= x) {
                    if (type !== 'single') {
                        dist = Math.abs(p.xScale.position(v[p.config.xDataKey], p.config.barPosition) - x);
                    } else {
                        if (p.config.stacked) {
                            //implement me
                        } else {
                            dist = Math.abs(p.getGroupedBarPosition(v, null, d.key, p.config.barPosition) - x);
                        }
                    }
                    cps[i].point = v;
                    cps[i].dist = dist;
                }
            }
        });

        //only return series that were within buffer
        cps = cps.filter(function (d) {
            if (!sonic.isSet(d.point)) {
                return false;
            }
            if (sonic.isSet(p.config.tooltip.buffer) && sonic.isSet(p.config.tooltip.buffer.amount)) {
                if (p.config.tooltip.buffer.type === 'value') {
                    if (p.xScale.domainRangeToInterval(Math.abs(p.xScale.position(d.point[p.config.xDataKey]) - mouse[0])) > p.config.tooltip.buffer.amount) {
                        return false;
                    }
                } else {
                    if (Math.abs(p.xScale.position(d.point[p.config.xDataKey]) - mouse[0]) > p.config.tooltip.buffer.amount) {
                        return false;
                    }
                }
            }
            return true;
        });

        //filter out closest bar
        if (type === 'single' && cps.length > 0) {
            closest = cps[0];
            cps.forEach(function(d) {
                if (d.dist < closest.dist) closest = d;
            });
            cps = [closest];
        }

        //so that the closest point order matches stack order
        if (p.config.type === 'stacked') {
            cps.reverse();
        }

        return cps;
    };

    /**
     * Update tooltips
     */
    p.updateTooltips = function (mouse, cps) {
        var content,
            renderFn = p.config.tooltip.renderFn || p.renderTooltips;

        if (p.config.tooltip) {
            if (mouse && cps.length > 0) {
                p.config.tooltip.closestPoints = cps;
                p.config.tooltip.content = renderFn(cps, mouse);
                p.config.tooltip.associatedId = bar.id();
                p.config.tooltip.mouse = mouse;

                viz.showTooltip(p.config.tooltip);
            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    /**
     * Default render tooltip function
     */
    p.renderTooltips = function (cps, mouse) {
        return cps.map(function (cp) {
            var html = '<p>';
            if (cps.length > 1 || (p.config.tooltip && p.config.tooltip.type === 'global')) {
                html = html + '<b><u>' + cp.key + '</u></b><br />';
            }

            html = html + '<b>' + p.config.xDataKey + ':</b>' + cp.point[p.config.xDataKey] + '<br />' +
                '<b>' + p.config.yDataKey + ':</b>' + cp.point[p.config.yDataKey];

            return html + '</p>';
        }).reduce(function (last, curr) {
            return last + curr;
        });
    };

    sonic.augment(bar, p, viz, 'registerable', 'listenable');

    //merge config
    bar.mergeConfig(initialConfig);

    //register this bar
    viz.register('sonic-bar', bar);

    return bar;
};

//add new bar instance
function sonic_bar_add (v, c) {
    v.body().call(sonic.bar(v, c));
}

//update existing bar instances
function sonic_bar_update (v, p, c, type) {
    var barType = (type || 'sonic-bar');
    v.find(barType, p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

function sonic_bar_remove (v, c) {
    v.remove('sonic-bar', c);
}

/* Public API Methods */
sonic_api.add('addBars', sonic_bar_add);
sonic_api.add('updateBars', sonic_bar_update);
sonic_api.add('removeBars', sonic_bar_remove);
