/**
 * A linear scale component
 */
sonic.scale.linear = function (viz, initialConfig) {
    var p = {
        d3Scale: null, //underlying d3 scale
        config: {
            /** 
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is 
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * The field that each data point uses for its scale value
             */
            dataKey: null,
            /**
             * The position of the scale (left, right, top, bottom) used 
             * to determine how to draw the range
             */
            pos: null,
            /**
             * Padding to add to scale as a percentage
             */
            pad: {},
            /**
             * The piece of the range to use to draw the scale within.  By 
             * default, will assume the full viz body height/width (depending 
             * on position), but this can be overridden.  For example, [0, .25]
             * would take up a quarter of viz body, along whichever 
             * edge the axis lies, [.25, .75] would take up middle 50%, etc.
             */
            range: null,
            /**
             * Minimum range the domain will span
             */
            minDomainRange: null
        }
    };

    /**
     * Scale constructor generates and returns a d3 scale
     */
    function scale() {
        p.d3Scale = d3.scale.linear()
            .domain(p.computeDomain());

        p.d3Scale.range(p.computeRange());
    }

    /** Update this scale instance */
    scale.update = sonic.override(function () {
        scale();
    });

    /**
     * Getter for underlying scale
     */
    scale.scale = function () {
        return p.d3Scale;
    };

    /**
     * Getter/setter for domain (e.g. [minVal, maxVal])
     *
     * setToMax, if this fn used as a setter, will broaden the 
     * existing domain based on both old and new domain, rather 
     * than just using the new one wholesale
     */
    scale.domain = function (domain, setToMax) {
        if (!sonic.isSet(domain)) {
            return p.d3Scale.domain();
        }

        if (setToMax) {
            p.d3Scale.domain(d3.extent(p.d3Scale.domain().concat(domain)));
        } else {
            p.d3Scale.domain(domain);
        }
    };

    scale.resetDomain = function () {
        scale.domain(p.computeDomain());
    };

    /**
     * Getter/setter for the domain min
     */
    scale.domainMin = function (min) {
        var preMin,
            newMin = min;
        if (!sonic.isSet(min)) {
            return p.d3Scale.domain()[0];
        }

        if (!sonic.isSet(p.config.min)) {
            if (p.config.pad.min) {
                preMin = p.d3Scale.domain()[0];
                newMin = min - (p.d3Scale.domain()[1] - min) * p.config.pad.min;
                if (p.config.adjustNearZero && preMin * newMin <= 0) {
                    newMin = 0;
                }
            }
            p.d3Scale.domain([newMin, p.d3Scale.domain()[1]]);
        }
    };

    /**
     * Getter/setter for the domain max
     */
    scale.domainMax = function (max) {
        var preMax,
            newMax = max;
        if (!sonic.isSet(max)) {
            return p.d3Scale.domain()[1];
        }

        if (!sonic.isSet(p.config.max)) {
            if (p.config.pad.max) {
                preMax = p.d3Scale.domain()[1];
                newMax = max + (max - p.d3Scale.domain()[0]) * p.config.pad.max;
                if (p.config.adjustNearZero && preMax * newMax <= 0) {
                    newMax = 0;
                }
            }
            p.d3Scale.domain([p.d3Scale.domain()[0], newMax]);
        }
    };

    /**
     * Getter for the domain extend
     */
    scale.domainExtent = function () {
        return p.d3Scale.domain()[1] - p.d3Scale.domain()[0];
    };

    /**
     * Find the nearest value to the point based in, based on the
     * data also passed in.
     *
     * This happens here because the scale knows the data key, and also
     * how to traverse the domain
     */
    scale.nearest = function (pnt, dat) {
        var nearest,
            val = pnt[p.config.dataKey];

        sonic.each(dat, function (k, v) {
            var currDist;

            currDist = Math.abs(v[p.config.dataKey] - val);

            if (!sonic.isSet(nearest)) {
                nearest = {};
            }

            if (!sonic.isSet(nearest.dist) || currDist < nearest.dist) {
                nearest.point = v;
                nearest.dist = currDist;

                if (currDist === 0) {
                    return false;
                }
            }
        });

        return nearest;
    };

    /**
     * Sort the values passed in, based on the data key
     */
    scale.sort = function (vals) {
        return vals.sort(sonic.sortByProp(p.config.dataKey));
    };

    /**
     * Getter for the range inputs
     */
    scale.rangeInputs = function () {
        return p.config.range;
    };

    /**
     * When updating scale in axis, will direct code
     * to scale.range. This function differs in each scale type
     */
    scale.resetScale = function (range) {
        return this.range(range);
    };

    /**
     * Getter/setter for the range itself
     */
    scale.range = function (range) {
        if (!sonic.isSet(range)) {
            return p.d3Scale.range();
        }

        p.config.range = range;
        p.d3Scale.range(p.computeRange());

        return scale;
    };

    /**
     * Getter for the range extent
     */
    scale.rangeExtent = function () {
        return sonic_scale_range_extent(scale);
    };

    /**
     * Getter for the range min
     */
    scale.rangeMin = function () {
        return d3.min(p.d3Scale.range());
    };

    /**
     * Getter for the range max
     */
    scale.rangeMax = function () {
        return d3.max(p.d3Scale.range());
    };

    /**
     * Getter for the position along the scale for 
     * the passed in value
     */
    scale.position = function (val) {
        return p.d3Scale(val);
    };

    /**
     * Getter for the data key
     */
    scale.dataKey = function () {
        return p.config.dataKey;
    };

    /**
     * Getter for the scale type
     */
    scale.type = function () {
        return 'linear';
    };

    /**
     * Compute the data domain for this scale.  Use the base scale domain generator, then 
     * do linear scale related checks/adjustments
     *
     * @todo some of these checks, like same domain min/max and config need to be rethought
     */
    p.computeDomain = function () {
        var domain,
            preDomain = {}, //used to keep track of original domain before changing
            offset,
            domainDelta;

        domain = sonic_scale_compute_base_domain(viz.data(), p.config);

        if (domain.length === 0) {
            return [0, 1];
        }

        //if domain min/max = the same, add a bit of offset using 10% of the value
        if (domain[0] === domain[1]) {
            offset = domain[0] * 0.1 < 5 ? 5 : domain[0] * 0.1;
            domain[1] = domain[1] + offset;
        }

        /** If padding desired, adjust the domain accordingly */
        if (p.config.pad) {
            if (p.config.pad.max) {
                preDomain.max = domain[1];
                domain[1] = domain[1] + (domain[1] - domain[0]) * p.config.pad.max;
                if (p.config.adjustNearZero && preDomain.max * domain[1] <= 0) {
                    domain[1] = 0;
                }
            }
            if (p.config.pad.min) {
                preDomain.min = domain[0];
                domain[0] = domain[0] - (domain[1] - domain[0]) * p.config.pad.min;
                if (p.config.adjustNearZero && preDomain.min * domain[0] <= 0) {
                    domain[0] = 0;
                }
            }
        }

        if (p.config.minDomainRange && (domain[1] - domain[0]) < p.config.minDomainRange) {
            domainDelta = Math.ceil((p.config.minDomainRange - (domain[1] - domain[0])) / 2);
            preDomain.min = domain[0];
            preDomain.max = domain[1];
            domain[0] = domain[0] - domainDelta;
            if (p.config.adjustNearZero && preDomain.min * domain[0] <= 0) {
                domain[0] = 0;
                domain[1] = domain[1] + domainDelta;
            }
            domain[1] = domain[1] + domainDelta;
            if (p.config.adjustNearZero && preDomain.max * domain[1] <= 0) {
                domain[1] = 0;
                domain[0] = domain[0] - domainDelta;
            }
        }

        return domain;
    };

    /**
     * Use the base scale fn to generate the pixel range to show scale within
     */
    p.computeRange = function () {
        return sonic_scale_compute_range(
            viz,
            p.config.pos,
            p.config.range
        );
    };

    sonic.augment(scale, p, viz, 'registerable');
    //merge config
    scale.mergeConfig(initialConfig);

    scale();

    viz.register('scale', scale);

    return scale;
};
