/**
 * Adds geo choropleth to viz
 *
 * @param {sonic.viz} viz the viz the lines are being added to
 * @param {Object} c - the line config (see below for options)
 */
sonic.geo.choropleth = function (viz, initialConfig) {
    var p = {
        scale: null, //scale to use for coloring of regions
        defaultColors: sonic.colors.colorMap(), //default colors
        projection: null, //projection of map
        path: null, //geo path generator (uses projection)
        config: {
            /**
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /** Set of css classes to add to the bars */
            cls: '',
            /** Which property of each data point to use for coloring */
            dataKey: 'val',
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component
             *
             * e.g. "bestKey", ["bestKey"], ["bestKey", "worstKey"]
             */
            seriesKeys: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component, based off of
             * the index of the series in the viz data
             *
             * e.g. 1, [1], [1, 3]
             */
            seriesIndexes: null,
            /** Manually set colors for buckets */
            colors: null,
            /** Color scheme (from colorbrewer) to use for buckets */
            colorScheme: 'Blues',
            /** Number of buckets to split data into */
            buckets: 9,
            /** Config for base geos */
            baseGeos: {
                /**
                 * Which base geo types to use
                 * Currently allows 'states' & 'counties' & 'nielsen_zones'
                 */
                types: [],
                /** County geo config */
                counties: {
                    mesh: false,
                    fill: '#A4A4A4',
                    stroke: 'none'
                },
                /** State geo config */
                states: {
                    mesh: true,
                    fill: 'none',
                    stroke: '#FFF'
                },
                /** Nielsen zones config */
                nielsen_zones: {
                    mesh: false,
                    fill: '#A4A4A4',
                    stroke: '#FFF'
                },
                /**
                 * Topology object to use
                 * @todo for now this must be passed in for base geos
                 * in future, should probably be able to be loaded
                 * by sonic
                 */
                topology: null
            },
            /** Projection properties */
            projection: {
                /** Projection type */
                type: 'albersUsa',
                /** Scale (how much to zoom) */
                scale: 1070,
                /**
                 * Where to center map on
                 * By default, show in center of viz body
                 */
                translate: 'center'
            },
            /** Tooltip config */
            tooltip: {
                /**
                 * Custom function to render the tooltips
                 *geo-polygon-highlight
                 * @param {Object...} Array of closest point objects which
                 * has the closest point, the distance to the mouse, and the
                 * series information
                 * @param {Number...} Mouse position in form [x, y]
                 * @return {String} html
                 */
                renderFn: null
            }
        }
    };

    /**
     * Constuctor renders choropleth
     *
     * @todo for now, renders 1 set of geos per data series included..which means
     * that if multiple series, will show charts on top of each other
     * default behavior should probably be to show 1 map per series next to one
     * another and shrink them
     */
    function choropleth(sel, opts) {
        var classes = [p.config.cls, 'sonic-choropleth', choropleth.id()],
            groups;

        //update d3 selection
        p.selection = sel;

        //set up geo properties of choropleth
        p.computeProjection();
        p.computePath();
        p.computeZoom();

        p.computeData(opts);
        p.setScales();

        //group for each series
        groups = sel.selectAll(classes.join('.'))
            .data(data, function (d) {
                return d.key;
            });

        //create groups for any new series
        groups.enter().append('g')
            .classed(classes.join(' '), true);

        groups.each(p.drawGeos);

        groups.exit().remove();
    }

    /**
     * Set data according to seriesKeys & seriesIndexes
     */
    p.computeData = function (opts) {
        opts = opts || {};
        data = [];

        if (opts.remove) {
            return;
        }

        data = viz.dataBySeries(p.config.seriesKeys, p.config.seriesIndexes);
    };

    /**
     * Bin the choropleth values into buckets that will be later used
     * to color the regions differently, based on where in scale they fall
     */
    p.setScales = function () {
        p.scale = d3.scale.quantile()
            .domain(
                data.reduce(function (prev, curr) {
                    return prev.concat(
                        sonic.array.pluck(curr.values, p.config.dataKey)
                    );
                }, [])
            )
            .range(d3.range(0, p.config.buckets));
    };

    /**
     * Draw the geos for the current series
     */
    p.drawGeos = function (series, seriesIndex) {
        var el = this,
            baseTypes = [
                {
                    key: 'countyId',
                    type: 'counties'
                },
                {
                    key: 'stateId',
                    type: 'states'
                },
                {
                    key: 'dmaId',
                    type: 'nielsen_zones'
                }
            ];

        baseTypes.forEach(function (d) {
            if (p.config.baseGeos.types.indexOf(d.type) !== -1) {
                if (p.config.baseGeos[d.type].mesh) {
                    p.drawMeshFeature.call(el, d, series, seriesIndex);
                } else {
                    p.drawMultiFeature.call(el, d, series, seriesIndex);
                }
            }
        });
    };

    p.drawMeshFeature = function (typeInfo) {
        var groups,
            type = typeInfo.type;

        //only want one group of a meshed feature
        groups = d3.select(this).selectAll('.' + type)
                .data([1]);

        //add to groups list
        groups.enter().append('g')
            .classed(type, true)
                .append('path');

        //update the path (note, it's only 1 path, not many) and set style
        groups.select('path')
            .datum(topojson.mesh(
                p.config.baseGeos.topology,
                p.config.baseGeos.topology.objects[type],
                function (a, b) { return a !== b; }
            ))
            .style('fill', p.config.baseGeos[type].fill)
            .style('stroke', p.config.baseGeos[type].stroke)
            .attr('d', p.path);
    };

    p.drawMultiFeature = function (typeInfo, series, seriesIndex) {
        var type = typeInfo.type,
            vals = series.values,
            features,
            groups;

        //sort data according to type key
        vals.sort(sonic.sortByProp(typeInfo.key));

        //only want one group for feature list
        groups = d3.select(this).selectAll('.' + type)
                .data([1]);

        //add new feature group
        groups.enter().append('g')
            .classed(type, true);

        //draw path for each feature in topology
        features = groups.selectAll('path')
            .data(
                topojson.feature(
                    p.config.baseGeos.topology,
                    p.config.baseGeos.topology.objects[type]
                ).features,
                function (d) {
                    return d.id;
                }
            );

        //add new features, and set up interaction for each
        features.enter().append('path')
            .on('mouseover', function (d, i) {
                d3.select(this).classed('sonic-geo-polygon-highlight', true);
                p.updateTooltips(d.id, viz.mouse(this));
            })
            .on('mouseout', function (d, i) {
                d3.select(this).classed('sonic-geo-polygon-highlight', false);
                p.updateTooltips();
            })
            .on('click', p.handleClick);

        //transition features' path, as well as styling
        //the fill style is what makes the choropleth a choropleth
        features
            .transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .style('stroke', p.config.baseGeos[type].stroke)
            .style('fill', function (d) {
                var match;

                //find matching data point from this data series
                match = sonic.array.binarySearch(
                    series.values,
                    function (v) {
                        return v[typeInfo.key] < d.id ? -1 :
                                (v[typeInfo.key] > d.id ? 1 : 0);
                    }
                );

                //Get choropleth color, or if no bucket found, use base color
                return p.getColor(
                    sonic.isSet(match) ? series.values[match][p.config.dataKey] : null
                ) || p.config.baseGeos.counties.fill;
            })
            .attr('d', p.path);
    };

    /**
     * Update tooltips
     */
    p.updateTooltips = function (id, mouse) {
        var content,
            renderFn = p.config.tooltip.renderFn || p.renderTooltips,
            cp;

        if (mouse) {
            cp = p.closestPoints(id);
        }

        if (p.config.tooltip) {
            if (sonic.isSet(id)) {
                p.config.tooltip.mouse = mouse;
                p.config.tooltip.associatedId = choropleth.id();
                p.config.tooltip.content = renderFn(cp, mouse);
                p.config.tooltip.cp = cp;
                viz.showTooltip(p.config.tooltip);

            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    /**
     * Find closest points to mouse
     */
    p.closestPoints = function (id) {
        var cp = data[0].values;

        cp = cp.filter(function (d) {
            return (d.dmaId === id);
        });

        return cp;
    };

    /**
     * Default render tooltip function
     */
    p.renderTooltips = function (cp, mouse) {
        return '<p>' + "id : " + cp.dmaId;
    };

    /**
     * Compute projection of choropleth map
     *
     * Use existing projection properties if they exist (so that map stays
     * zoomed/panned to where it was before), otherwise use initial config
     */
    p.computeProjection = function () {
        var translate = [viz.body().width() / 2, viz.body().height() / 2];

        if (p.projection) {
            translate = p.projection.translate();
        } else if (sonic.isArray(p.config.projection.translate)) {
            translate = p.config.projection.translate;
        }

        p.projection = d3.geo[p.config.projection.type]()
            .scale(p.projection ? p.projection.scale() : p.config.projection.scale)
            .translate(translate);
    };

    /**
     * Compute geo path used by geos
     */
    p.computePath = function () {
        p.path = d3.geo.path()
            .projection(p.projection);
    };

    /**
     * Compute geo path used by geos
     */
    p.computeZoom = function () {
        viz.body().call(
            d3.behavior.zoom()
                .translate(p.projection.translate())
                .scale(p.projection.scale())
                //@todo figure out what this does, and configure
                .scaleExtent([viz.body().height(), 8 * viz.body().height()])
                .on('zoom', p.handleZoom)
        );
    };

    /**
     * Get choropleth color for the passed in value
     * by looking where it falls in the scale
     *
     * If colors manually set in config, use them.  Otherwise,
     * if colorbrewer library included, use them.  Fall back to
     * default colors.
     */
    p.getColor = function (value) {
        var bucket = p.scale(value),
            color;

        if (!value) {
            return;
        }

        if (p.config.colors) {
            color = p.config.colors[bucket];
        } else if (colorbrewer) {
            color = colorbrewer[p.config.colorScheme][Math.min(p.config.buckets, 9)][bucket];
        } else {
            color = p.defaultColors(bucket);
        }

        return color;
    };

    /**
     * On click of a geo, zoom to centroid of clicked geo
     */
    p.handleClick = function (d) {
        var centroid = p.path.centroid(d),
            currTranslation = p.projection.translate();

        //set new translation on projection
        //@todo better understand what's happening here
        p.projection.translate([
            currTranslation[0] - centroid[0] + viz.body().width() / 2,
            currTranslation[1] - centroid[1] + viz.body().height() / 2
        ]);
        //update all paths in current selection
        p.selection.selectAll('path').transition()
            .duration(2000)
            .attr('d', p.path);
    };

    /**
     * On zoom of container where zoom has been set up,
     * zoom in on the point based on where it happened and how far
     * zoomed in user now is
     */
    p.handleZoom = function () {
        //update translation and scale based on current settings (last event properties)
        p.projection.translate(d3.event.translate).scale(d3.event.scale);
        //update all paths in current selection
        p.selection.selectAll('path').attr('d', p.path);
    };

    sonic.augment(choropleth, p, viz, 'registerable');
    //merge config
    choropleth.mergeConfig(initialConfig);
    //register this point
    viz.register('sonic-choropleth', choropleth);

    return choropleth;
};

/**
 * Add a choropleth to the viz body
 */
function sonic_choropleth_add(v, c) {
    v.body().call(sonic.geo.choropleth(v, c));
}

/**
 * Update matching choropleths in viz v, based on params p,
 * to have config c
 */
function sonic_choropleth_update(v, p, c) {
    v.find('sonic-choropleth', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

/**
 * Remove choropleth from the viz body
 */
function sonic_choropleth_remove(v, c) {
    v.remove('sonic-choropleth', c);
}

/* Public API Methods */
sonic_api.add('addChoropleth', sonic_choropleth_add);
sonic_api.add('updateChoropleth', sonic_choropleth_update);
sonic_api.add('removeChoropleth', sonic_choropleth_remove);
