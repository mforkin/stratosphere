/**
 * Adds lines to the viz.  Can be used to show one line, or many.
 *
 * @param {sonic.viz} viz the viz the lines are being added to
 * @param {Object} c - the line config (see below for options)
 */
sonic.line = function (viz, initialConfig) {
    var p = {
        xScale: null, //xScale for line
        yScale: null, //yScale for line
        defaultColors: sonic.colors.colorMap(), //default colors
        colors: [], //current colors
        config: {
            /**
             *  Unique id for this set of bars
             *  Note: A unique id will be generated by framework - this is
             *  just useful for a way to get the bars by an id that you know
             */
            id: null,
            /**
             * Set of css classes to add to the bars
             */
            cls: '',
            /**
             * The field that makes each data point unique
             */
            definedDataKey: 'id',
            /**
             * The field that each data point uses for its x-axis value
             */
            xDataKey: 'x',
            /**
             * The field that each data point uses for its y-axis value
             */
            yDataKey: 'y',
            /**
             * Which scale (by id) to use for the x-axis.  Can be passed in, otherwise
             * auto-generated based on xDataKey
             */
            xScaleId: null,
            /**
             * Which scale (by id) to use for the y-axis.  Can be passed in, otherwise
             * auto-generated based on yDataKey
             */
            yScaleId: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component
             *
             * e.g. "bestKey", ["bestKey"], ["bestKey", "worstKey"]
             */
            seriesKeys: null,
            /**
             * Value or array of values that indicate which series in the viz's data
             * should be used as data for this component, based off of
             * the index of the series in the viz data
             *
             * e.g. 1, [1], [1, 3]
             */
            seriesIndexes: null,
            /**
             * Stroke color
             *
             * Note: Will use series colors instead from data if they are defined
             * Note 2: If multiple lines, and no series colors, will use the default
             * color list.
             * @todo should rethink what rules for color should be (you may want
             * the same color for multiple lines)
             */
            stroke: 'black',
            /**
             * Fill color
             *
             * Note: Will use series colors instead from data if they are defined
             * Note 2: If multiple lines, and no series colors, will use the default
             * color list.
             * @todo should rethink what rules for color should be (you may want
             * the same color for multiple lines)
             */
            fill: 'black',
            /** Stroke width */
            strokeWidth: 3,
            /** Fill opacity */
            fillOpacity: 1,
            /** Whether to show a circle at every point along the line */
            showPoints: false,
            /** Whether to show a circle as the line is hovered over */
            showPointTracer: true,
            /** Radius of the point circles*/
            pointSize: 4,
            /** Radius of the point circles, when highlighted/selected */
            highlightPointSize: 6,
            /**
             * If too many points, and showPoints enabled, forcibly don't show
             * the circles since there are too many to see clearly
             */
            minPixelsPerPoint: 20,
            /**
             * Whether to sort the data before rendering
             */
            sort: false,
            /** Tooltip config */
            tooltip: {
                /**
                 * Only show the tooltip if closest point is within a certain
                 * buffer area - can be by value, or by pixel
                 */
                buffer: {
                    type: 'value', //or pixel
                    amount: null //value, or px amount
                },
                type: 'grouped', //todo implement single (1 per line)
                /**
                 * Custom function to render the tooltips
                 *
                 * @param {Object...} Array of closest point objects which
                 * has the closest point, the distance to the mouse, and the
                 * series information
                 * @param {Number...} Mouse position in form [x, y]
                 * @return {String} html
                 */
                renderFn: null
            }
        }
    };

    /**
     * Line constructor renders the lines/points
     *
     * @param {d3.selection} sel where to render the lines to
     * @param {Object} opts extra information on how to render the lines
     *   generally used to specify custom transitions
     */
    function line(sel, opts) {
        var classes = [p.config.cls, 'sonic-line'],
            groups;

        //update this line instance's selection to match the current one
        p.selection = sel;

        p.computeData(opts || {});
        p.setScales();
        p.computeColors();

        //group for each series
        //@todo should this by defined explicitly by key?
        groups = sel.selectAll('.sonic-line.' + p.config.id)
            .data(p.data);

        //create groups for any new series
        groups.enter().append('g')
            .classed('sonic-line ' + p.config.id, true)
            .append('path')
                .attr('stroke-width', p.config.strokeWidth)
                .attr('fill-opacity', 0);

        //update the color for existing groups
        groups
            .attr('stroke', function (d, i) {
                return p.colors[i];
            })
            .attr('fill', function (d, i) {
                return p.colors[i];
            });

        //draw lines/points/tracer points for each series
        groups.each(p.drawLine);
        groups.each(p.drawPoints);
        groups.each(p.drawTracerPoint);
        groups.each(p.setupLegend);

        //remove old lines
        groups.exit().remove();

        //Since we just tried to draw a line, we ask the viz to check
        //for content to appropriately update its no data message
        viz.registerVisibleContent(line, line.hasContent());
    }

    /**
     * Compute this instance's data from the viz data, using the passed
     * in series keys or indexes
     */
    p.computeData = function (opts) {
        p.data = [];
        if (opts.remove) {
            return;
        }
        //We filter out series with empty values because they will break the
        //line generator and would draw nothing anyways
        p.data = viz
                .dataBySeries(p.config.seriesKeys, p.config.seriesIndexes)
                .filter(function (d, i) {
                    if (d.values.length > 0) {
                        return true;
                    }
                });
    };

    /**
     * Sets the x and y scales for this instance  If an actual scale
     * passed in, uses that.  If a scale id passed in, use it,
     * otherwise find the appropiate scale from the datakey.
     */
    p.setScales = function () {
        if (sonic.isSet(p.config.xScale)) {
            p.xScale = p.config.xScale;
            p.config.xScaleId = viz.register('scale', p.xScale);
            delete p.config.xScale;
        } else {
            if (p.config.xScaleId) {
                p.xScale = viz.findOne('scale', p.config.xScaleId);
            } else {
                p.xScale = viz.findOne('scale', { dataKey: p.config.xDataKey });
                p.config.xScaleId = p.xScale.id();
            }
        }

        if (sonic.isSet(p.config.yScale)) {
            p.yScale = p.config.yScale;
            p.config.yScaleId = viz.register('scale', p.yScale);
            delete p.config.yScale;
        } else {
            if (p.config.yScaleId) {
                p.yScale = viz.findOne('scale', p.config.yScaleId);
            } else {
                p.yScale = viz.findOne('scale', { dataKey: p.config.yDataKey });
                p.config.yScaleId = p.yScale.id();
            }
        }
    };

    /**
     * Compute the line colors
     *
     * If 1 line, use series color, or stroke color from config
     * If multiple lines, use series colors, or default colors
     *
     * @todo allow multiple lines to have same color based on config
     * @todo this needs to be cleaned up
     */
    p.computeColors = function () {
        p.data.forEach(function (d, i, arr) {
            if (arr.length > 1) {
                //if more than 1 line, use default color list as backup
                p.colors[i] = d.color || p.defaultColors(i);
            } else {
                //if only 1 line, use config stroke as backup
                p.colors[i] = d.color || p.config.stroke;
            }
        });
    };

    p.lineGenerator = function () {
        return d3.svg.line()
            .defined(function (d) {
                return sonic.isSet(d[p.config.definedDataKey]);
            })
            .x(function (d) {
                return p.xScale.position(d[p.config.xDataKey], 'center');
            })
            .y(function (d) {
                return p.yScale.position(d[p.config.yDataKey], 'center');
            });
    };

    p.setupLegend = function (series, i) {
        d3.select(this).selectAll('path')
            .attr(line.id() + '-data-legend', function (s) {
                return series.name || series.key;
            });
    };

    /**
     * Draw line for the given series
     */
    p.drawLine = function (series, i) {
        var lineGen = p.lineGenerator();

        d3.select(this).selectAll('path')
            .data(p.data).transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('d', function (d) {
                var vals = series.values;
                if (p.config.sort) {
                    vals = p.xScale.sort(vals);
                }
                return lineGen(vals);
            });
    };

    /**
     * Draw points for the given line series
     */
    p.drawPoints = function (series, i) {
        var dat = [],
            points;

        //if showPoints is true and there's enough space for them, set
        //the data to the series values, otherwise, leave empty so any
        //existing points go away
        if (p.config.showPoints &&
                p.config.minPixelsPerPoint < (viz.body().width() / series.values.length)) {

            dat = series.values;
        }

        points = d3.select(this).selectAll('circle.line-point')
            .data(dat);

        points.enter().append('circle')
            .classed(p.config.id + ' line-point', true)
            .attr('fill-opacity', p.config.fillOpacity);

        points.transition()
            .delay(viz.animation().delay)
            .duration(viz.animation().duration)
            .attr('cx', function (d) {
                return p.xScale.position(d[p.config.xDataKey], 'center');
            })
            .attr('cy', function (d) {
                return p.yScale.position(d[p.config.yDataKey], 'center');
            })
            .attr('r', p.config.pointSize);

        points.exit().remove();
    };

    /**
     * Draw a tracer point for the given series
     *
     * Actually adds two points, one for the hover
     * and one for the click
     */
    p.drawTracerPoint = function (series, i) {
        var dat = [],
            points;

        //if tracer desired, add 1 for both hover/click, otherwise
        //leave empty so existing ones are removed
        if (p.config.showPointTracer === true) {
            dat.push(
                {
                    type: 'mouse'
                },
                {
                    type: 'click'
                }
            );
        } else if (p.config.showTracerPoint !== false) {
            dat.push(
                {
                    type: p.config.showPointTracer
                }
            );
        }

        points = d3.select(this).selectAll('circle.tracer-point')
            .data(dat);

        points.enter().append('circle')
            .attr('class', function (d) {
                return p.config.id + ' ' + series.key +
                    ' tracer-point ' + d.type;
            })
            .attr('fill-opacity', 0.8)
            .attr('opacity', 0)
            .attr('r', p.config.highlightPointSize);

        points
            .attr('cx', function (d, i) {
                var cpId = this.getAttribute('cpId'),
                    pos = 0,
                    matches = [];

                //find x position to show point by using the point's
                //id, and then looking through the values to find that
                //point's x value
                if (cpId) {
                    matches = series.values.filter(function (dp) {
                        return sonic.isDate(dp.id) ?
                                (dp.id.getTime().toString() === cpId) : (dp.id.toString() === cpId);
                    });

                    if (matches.length > 0) {
                        pos = p.getPositionFromCP([{point: matches[0]}], 0)[0];
                    }
                }

                return pos;
            })
            .attr('cy', function (d, i) {
                var cpId = this.getAttribute('cpId'),
                    pos = 0,
                    matches = [];

                //find y position to show point by using the point's
                //id, and then looking through the values to find that
                //point's x value
                if (cpId) {
                    matches = series.values.filter(function (dp) {
                        return sonic.isDate(dp.id) ?
                                (dp.id.getTime().toString() === cpId) : (dp.id.toString() === cpId);
                    });

                    if (matches.length > 0) {
                        pos = p.getPositionFromCP([{point: matches[0]}], 0)[1];
                    }
                }

                return pos;
            });

        points.exit().remove();
    };

    /**
     * On viz mouse move, find closest points
     * and update tooltips accordingly
     */
    p.onVizMouseMove = function (mouse) {
        var cps = [];

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        p.updateTooltips(mouse, cps);

        //only update non-selected points so selected ones
        //stay highlighted
        d3.selectAll('.' + line.id() + '.tracer-point.mouse')
            .attr('cx', function (d, i) {
                var pos = p.getPositionFromCP(cps, i);
                return pos ? pos[0] : 0;
            })
            .attr('cy', function (d, i) {
                var pos = p.getPositionFromCP(cps, i);
                return pos ? pos[1] : 0;
            })
            .attr('opacity', function (d, i) {
                return (mouse && p.getPositionFromCP(cps, i)) ? 1 : 0;
            })
            .attr('stroke', function (d, i) {
                return (cps && cps[i]) ? cps[i].color : null;
            })
            .attr('fill', function (d, i) {
                return (cps && cps[i]) ? cps[i].color : null;
            });

        return cps;
    };

    /*
     * On viz mouse click, find closest points,
     * update tracer to put the click tracer there,
     * and then return them
     */
    p.onVizClick = function (mouse) {
        var cps;

        if (mouse) {
            cps = p.closestPoints(mouse);
        }

        //hide hover circle when click happens because it's distracting
        d3.selectAll('.' + line.id() + '.tracer-point.mouse')
            .attr('opacity', 0);

        d3.selectAll('.' + line.id() + '.tracer-point.click')
            .attr('cx', function (d, i) {
                var pos = p.getPositionFromCP(cps, i);
                return pos ? pos[0] : 0;
            })
            .attr('cy', function (d, i) {
                var pos = p.getPositionFromCP(cps, i);
                return pos ? pos[1] : 0;
            })
            .attr('cpId', function (d, i) {
                //set the point's id so that the tracer can use it later
                //to figure out it's x/y values
                var id = null;
                if (cps && cps.length > 0 && cps[i]) {
                    //@todo this check shouldn't need to happen...should use
                    //scale or something
                    id = sonic.isDate(cps[i].point.id) ? cps[i].point.id.getTime() : cps[i].point.id;
                }
                return id;
            })
            .attr('opacity', function (d, i) {
                //if clicked, show...if clickout, don't show
                return (mouse && p.getPositionFromCP(cps, i)) ? 1 : 0;
            });

        return cps;
    };

    /**
     * Find closest points to mouse.
     * Note changes: will only be a valid closestPoint if within the yScale of the viz.
     */
    p.closestPoints = function (mouse) {
        var cps = [],
            inRange,
            noConfig,
            x = mouse[0],
            y = mouse[1],
            cpDist = null;

        if(p.config.tooltip && sonic.isSet(p.config.tooltip.buffer.value) === true) {
            inRange = (y >= p.yScale.rangeMin() && y <= p.yScale.rangeMax());
            if (inRange === false) {
                return [];
            }
        } else {
            noConfig = true;
        }

        if (inRange || noConfig) {

            cps = p.data.map(function (d) {
                var cp = {
                    xDist: null,
                    point: null
                };

                sonic.each(d, function (k, v) {
                    if (k !== 'values') {
                        cp[k] = v;
                    }
                });

                return cp;
            });

            p.data.forEach(function (d, i) {
                d.values.forEach(function (v) {
                    var xDist = Math.abs(p.xScale.position(v[p.config.xDataKey], 'center') - x),
                        yDist = Math.abs(p.yScale.position(v[p.config.yDataKey], 'center') - y);

                    if (!cps[i].point || xDist < cps[i].xDist) {
                        //check to make sure point is within buffer before
                        //considering it actually a close point
                        if (p.pointWithinBuffer(v, xDist)) {
                            cps[i].point = v;
                            cps[i].xDist = xDist;
                            cps[i].yDist = yDist;
                        }
                    }
                });
            });

            //if no closest points in a series, don't return that series
            cps = cps.filter(function (d) {
                return (sonic.isSet(d.point)) ? true : false;
            });

            return cps;
        }
    };

    /**
     * Update tooltips
     */
    p.updateTooltips = function (mouse, cps) {
        var renderFn;

        if (p.config.tooltip) {
            renderFn = p.config.tooltip.renderFn || p.renderTooltips;
            p.config.tooltip.associatedId = line.id();
            if (mouse) {
                if (cps.length > 0) {
                    p.config.tooltip.closestPoints = cps;
                    p.config.tooltip.content = renderFn(cps, mouse);
                    p.config.tooltip.mouse = mouse;
                    viz.showTooltip(p.config.tooltip);
                } else {
                    viz.removeTooltip(p.config.tooltip);
                }
            } else {
                viz.hideTooltip(p.config.tooltip);
            }
        }
    };

    /**
     * Default render tooltip function
     */
    p.renderTooltips = function (cps, mouse) {
        return cps.map(function (cp) {
            var html = '<p>';
            if (cps.length > 1 || (p.config.tooltip && p.config.tooltip.type === 'global')) {
                html = html + '<b><u>' + cp.key + '</u></b><br />';
            }

            html = html + '<b>' + p.config.xDataKey + ':</b>' + cp.point[p.config.xDataKey] + '<br />' +
                '<b>' + p.config.yDataKey + ':</b>' + cp.point[p.config.yDataKey];

            return html + '</p>';
        }).reduce(function (last, curr) {
            return last + curr;
        });
    };

    /**
     * Is the point, alongside its px distance within the buffer?
     *
     * Can use value, or pixel as buffer
     */
    p.pointWithinBuffer = function (point, pxDistance) {
        var withinBuffer = true;

        if (p.config.tooltip && sonic.isSet(p.config.tooltip.buffer.amount)) {
            if (p.config.tooltip.buffer.type === 'value') {
                if (p.xScale.domainRangeToInterval(pxDistance) >
                        p.config.tooltip.buffer.amount) {
                    withinBuffer = false;
                }
            } else {
                if (pxDistance > p.config.tooltip.buffer.amount) {
                    withinBuffer = false;
                }
            }
        }

        return withinBuffer;
    };

    /**
     * Get x/y position for a given closest point passed in
     */
    p.getPositionFromCP = function (cps, i) {
        return (cps && cps.length > 0 && cps[i]) ? [
            p.xScale.position(cps[i].point[p.config.xDataKey], 'center'),
            p.yScale.position(cps[i].point[p.config.yDataKey])
        ] : null;
    };

    /**
     * Is the current point one of the closest points that has been
     * identified elsewhere
     */
    p.isClosestPoint = function (type, d, closestPoints) {
        if (!sonic.isArray(closestPoints)) {
            return false;
        }

        return closestPoints.filter(function (cp) {
            return cp.key === type &&
                cp.point[p.config.definedDataKey] === d[p.config.definedDataKey];
        }).length > 0;
    };

    /**
     * Get line point radius based on config and whether the point
     * is currently highlighted
     */
    p.getLinePointRadius = function (d, i, closestPoints) {
        var groupKey = d3.select(this.parentNode).data()[0].key,
            size = p.config.pointSize;

        if (sonic.isSet(closestPoints) &&
                p.isClosestPoint(groupKey, d, closestPoints)) {
            size = p.config.highlightPointSize;
        }

        return size;
    };

    sonic.augment(line, p, viz, 'registerable', 'listenable');
    //merge config
    line.mergeConfig(initialConfig);
    //register this line
    viz.register('sonic-line', line);

    return line;
};

/**
 * Add a line(s) to the viz body
 */
function sonic_line_add (v, c) {
    v.body().call(sonic.line(v, c));
}


/**
 * Remove a line from the viz body
 */
function sonic_line_remove (v, c) {
    v.remove('sonic-line', c);
}


/**
 * Update matching lines in viz v, based on params p,
 * to have config c
 */
function sonic_line_update (v, p, c) {
    v.find('sonic-line', p).forEach(function (cmp) {
        cmp.mergeConfig(c);
        cmp.update();
    });
}

/* Public API Methods */
sonic_api.add('addLine', sonic_line_add);
sonic_api.add('addLines', sonic_line_add);
sonic_api.add('updateLine', sonic_line_update);
sonic_api.add('updateLines', sonic_line_update);
sonic_api.add('removeLine', sonic_line_remove);
sonic_api.add('removeLines', sonic_line_remove);
